![《JavaScript编程全解》](.\images\《看透javascript%20原理、方法与实践》.jpg)

## 第 1 章 JavaScript 怎么学

#### 1.2.3 JavaScript 是一种事件驱动的语言
> 事件驱动是指 JavaScript 引擎并不是在看到代码之后就会立即执行，而是会在合适的时间才去执行。这个合适的时间是指当某个事件发生之后（例如一个输入框的内容发生了变化，这就是一个事件） 。 只有当相应的事件发生了之后，相应的操作才会执行，这就是事件驱动。

## 第 4 章 function 类型对象
#### 4.1.3 两种创建方式的关系
> 在 JS 中所有的数据只有两种存在形式，要么是对象的属性，要么是变量，函数也不例外，无论是对象的属性还是变量都是名值对的结构，因此函数也应该是这种名值对的结构，由函数表达式可以很容易看明白这一点。 
> 其实，通过函数声明方式创建函数时， JS 在背后自动帮用户做了这件事情，它首先创建了函数对象，然后又创建了跟函数名同名的变量，并将创建出来的函数赋值给了这个变量。 

### 4.3 处理业务
#### 4.3.2 操作符
> `>> 和 >>>`
> 这两个符号的作用都是右移位。 
> 在计算机中保存的数据（主要指整数）也像平时所写的数一样，除了数字本身外还有“位”的概念，例如4567 这个数的千位为 4，百位为 5 ，十位为 6，个位为 7，把不同的数字放到不同的位，其权重就不一样了。 
> 假如现在的数只有 4 位（就像某些需要填数字的单据上一格填一个数字，一共有 4 格，只能填 4 个数字），那么 4567 左移一位就是 5670，左移两位就是 6700，而右移一位就成了 0456，右移两位就成了 0045 。 
> 在计算机中的左移右移跟这里类似，只是它不一定是 4 位，而且每一位都只能是 0 或 1 。 
> 在程序中经常使用左移右移来做 2 的整数倍的乘除法，这就像十进制中左移一位扩大 10 倍右移一位缩小到原来的 1110 一样，不过左移右移要比乘除法的计算简单很多。 对于处理器来说也一样，移位要比计算乘除速度快。
> 不过计算机中的移位跟上述十进制的移位还是存在区别的。 
> 在计算机中因为只有 0 和 I'所以为了区分正负数，现有的做法是将负数用补码来表示，这样只要看最高位是 0 还是 I '就可以区分正负数了（这里只要知道有符号数将最高位用作符号位，符号位 0 表示正数，符号位 1 表示负数即可）。 但是这时候问题就来了，对于一个负数来说，右移一位后其符号位（最高位）正常应该变成 0，这样就变成正数了，此时就会出现问题了，因此在右移的时候对有符号数和无符号分别使用了不同的操作符。
> 当然，这只是表层的区别，在底层有符号数和无符号数使用的是两套不同的进位／溢出标志，例如 x86 处理器中有符号数用 OF，无符号数用 CF 标志。
>  另外，数据本身只是一串由0 和 1 组成的编码， 是无法区分有符号数还是无符号数的，只是人为将其看作有符号数或者无符号数而已（在程序的底层会通过类型标志进行区分）。 
> 对于一些强类型语言来说，在定义数据的时候就会指定数据的类型，这样在使用时，就可以清楚地知道应该将其看作有符号数还是无符号数。 
> 因为 JS 是一种弱类型语言，变量的类型可以任意转换，所以对于`-1>>>0`。这样的操作来说，操作的目标是表示 1 的一串数（对于 32 位数来说就是 OXFFFFFFFF，即 32个 I ），操作的过程是将其当作无符号数左移 0 位，这时虽然不会对数字本身做任何修改，但是，因为在操作的过程中已经将其看作无符号数，所以其结果也就变成了 4294967295，即无符号数的 32 个 1 ，同样这也是有符号数一l 的 32 位编码。