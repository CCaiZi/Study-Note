![《JavaScript编程全解》](.\images\《看透javascript%20原理、方法与实践》.jpg)

## 第 1 章 JavaScript 怎么学

#### 1.2.3 JavaScript 是一种事件驱动的语言
> 事件驱动是指 JavaScript 引擎并不是在看到代码之后就会立即执行，而是会在合适的时间才去执行。这个合适的时间是指当某个事件发生之后（例如一个输入框的内容发生了变化，这就是一个事件） 。 只有当相应的事件发生了之后，相应的操作才会执行，这就是事件驱动。

## 第 4 章 function 类型对象
#### 4.1.3 两种创建方式的关系
> 在 JS 中所有的数据只有两种存在形式，要么是对象的属性，要么是变量，函数也不例外，无论是对象的属性还是变量都是名值对的结构，因此函数也应该是这种名值对的结构，由函数表达式可以很容易看明白这一点。 
> 其实，通过函数声明方式创建函数时， JS 在背后自动帮用户做了这件事情，它首先创建了函数对象，然后又创建了跟函数名同名的变量，并将创建出来的函数赋值给了这个变量。 

### 4.3 处理业务
#### 4.3.2 操作符
> `>> 和 >>>`
> 这两个符号的作用都是右移位。 
> 在计算机中保存的数据（主要指整数）也像平时所写的数一样，除了数字本身外还有"位"的概念，例如4567 这个数的千位为 4，百位为 5 ，十位为 6，个位为 7，把不同的数字放到不同的位，其权重就不一样了。 
> 假如现在的数只有 4 位（就像某些需要填数字的单据上一格填一个数字，一共有 4 格，只能填 4 个数字），那么 4567 左移一位就是 5670，左移两位就是 6700，而右移一位就成了 0456，右移两位就成了 0045 。 
> 在计算机中的左移右移跟这里类似，只是它不一定是 4 位，而且每一位都只能是 0 或 1 。 
> 在程序中经常使用左移右移来做 2 的整数倍的乘除法，这就像十进制中左移一位扩大 10 倍右移一位缩小到原来的 1110 一样，不过左移右移要比乘除法的计算简单很多。 对于处理器来说也一样，移位要比计算乘除速度快。
> 不过计算机中的移位跟上述十进制的移位还是存在区别的。 
> 在计算机中因为只有 0 和 I'所以为了区分正负数，现有的做法是将负数用补码来表示，这样只要看最高位是 0 还是 I '就可以区分正负数了（这里只要知道有符号数将最高位用作符号位，符号位 0 表示正数，符号位 1 表示负数即可）。 但是这时候问题就来了，对于一个负数来说，右移一位后其符号位（最高位）正常应该变成 0，这样就变成正数了，此时就会出现问题了，因此在右移的时候对有符号数和无符号分别使用了不同的操作符。
> 当然，这只是表层的区别，在底层有符号数和无符号数使用的是两套不同的进位／溢出标志，例如 x86 处理器中有符号数用 OF，无符号数用 CF 标志。
>  另外，数据本身只是一串由0 和 1 组成的编码， 是无法区分有符号数还是无符号数的，只是人为将其看作有符号数或者无符号数而已（在程序的底层会通过类型标志进行区分）。 
> 对于一些强类型语言来说，在定义数据的时候就会指定数据的类型，这样在使用时，就可以清楚地知道应该将其看作有符号数还是无符号数。 
> 因为 JS 是一种弱类型语言，变量的类型可以任意转换，所以对于`-1>>>0`。这样的操作来说，操作的目标是表示 1 的一串数（对于 32 位数来说就是 OXFFFFFFFF，即 32个 I ），操作的过程是将其当作无符号数左移 0 位，这时虽然不会对数字本身做任何修改，但是，因为在操作的过程中已经将其看作无符号数，所以其结果也就变成了 4294967295，即无符号数的 32 个 1 ，同样这也是有符号数一l 的 32 位编码。

---

> **在 JS 申函敏是怎么执行的**
> 函数无非两部分：数据和对数据的操作。 数据又分为外部数据和内部数据，对于外部数据，本书将在后边的作用域链中进行介绍。 内部数据又分为参数和变量两部分。 在函数每次执行的时候参数都会被赋予一个新值，而变量则每次都会被设直为一个相同的初始值。
> 函数的变量和参数是怎么保存的呢？对于多个数据来说，最常用也是最简单的保存方式就是使用数组保存，这样按序号查找起来就非常方便了 。 
> 而且，一般来说，一个函数的参数和变量都会集中保存在一个数纽或者跟数纽类似的结构（例如裁）中。 但是，数组本身存在一个非常致命的缺点，它要求每个元素的长度都相等，这对于参数（或变量）来说是很难符合要求的。 
> 但是，为了使用数纽（或我）的便捷性通常会在数组中保存一个包含地址的数据（除地址外，还可能包含数据类型等其他数据），而不是实际的数据，这样既可以使用数组，又可以保存不同长度的数据。 
> 此时，在函数中使用参数（或变量）的时候只需要使用"第几个参数（或变量）"就可以了，至于数组中具体一个元素使用多少位，则需要根据不同的硬件平台（例如，是 32 位还是 64 位）和具体引擎的开发者来确定。 
> 但是，这里还存在一个小问题，对于复杂的数据来说，这样保存无可厚非，而对于直接使用数组元素就可以保存的简单数据（例如整数）来说，再使用这种方式就显得复杂了，而且多一步通过地址查找数据的操作也会影响效率，因此这种情况一般会直接将值保存到数组中，而不是保存地址。
> 函数在每次执行之前都会新建一个参数数组和一个变量数纽（当然也可以合并为一个数组，而且通常会使用我来实现），然后将调用时所传递的参数设直到参数数组中，而变量数组在每次执行前都具有相同的内容，对数据进行操作时只需要使用"第几个参数"或者"第几个变量"即可。
> 简单的数据（例如整数）会直接保存在数组中，而对于复杂的数据，数组中只保存地址，具体的数据保存在堆中 。 
> 可以简单地将堆理解为一堆草纸，其所保存的数据是所有函数所共享的，不过也并不是每个函数都可以调用堆中所有的数据。 因为调用堆中数据的前提是能找到，如果找不到当然也就调用不了 。 
> 例如，在函数中定义了一个字符串的对象变量 s，这时就会将 s 的内容保存到堆中，然后将堆中所保存数据的地址保存到函数的变量数组中，这时对于函数外部来说，虽然可以访问堆中的数据，但是因为没有s 的地址，所以也就无法访问 s 这个字符串变量了 。

#### 4.3.5 闭包
> ```js
> function fl(){
>   var v=l;
>   function f2(){
>     var vl = l;
>     console.log(v+","+vl);
>     v++;
>     vl++;
>     return f2;
> }
> var f = fl ();
> f();  //1 ,1
> f();  //2 ,1
> f();  //3 ,1
> ```
> 从上面的例子可以看出， fl 中定义的变量 v 在每次调用时会累加，这说明每次调用时使用的都是原来的数据，而口中定义的变量 vl 则在每次调用时都会创建新的数据。
> 其原理其实非常简单，在函数 fl 执行时会创建一套 fl 的变量数组，在函数口执行时会创建另外一套口的变量数组。 按照 JS 中变量作用域链的规则，在口中可以调用执行 fl 时所创建的变量数组，为了口可以正确执行，只要在口还可能被调用的时候执行 fl 时所创建的执行环境（包括变量数组）就不会被释放，因此， fl 中定义的变量 v 会使用同一个，而口每次执行完之后所创建的执行环境就没用了，会被释放，而在下次执行时又会创建新的执行环境。

### 4.4 创建对象
#### 4.4.2 创建过程
> 使用"nction 创建 object 类型对象的过程可以简单地分为以下两步（可以这么理解，实际创建过程要复杂一些）。
> 1 ）创建 function 对应类型的空 object 类型对象。
> 2 ）将 function 的函数体作为新创建的 object 类型对象的方法来执行（主要目的是初始化object 对象）。
> 例如下面的例子。
> ```js
> function Car(color, displacement) {
>   this.color= color ;
>   this.displacement = displacement;
> }
> var car = new Car ("black","2.4T") ;
> console.log(car.color+","+car.displacement);  //black, 2.4T
> ```
> 这个例子中，首先创建了 function 类型的 Car，然后使用它新建 object 类型的 car 实例对象。
>  在新建 car 对象时首先会新建 Car 类型的空对象 car，然后再将 Car 函数作为新建对象的方法来调用，从而初始化新建的 car 实例对象，相当于下面的过程。
> ```js
> function Car(){)
> var car= new Car();
> car.init = function (color, displacement) {
> this.color = color;
> this.displacement = displacement;
> }
> car.init ("black","2.4T") ;
> console.log(car.color+","+car.displacement);  //black, 2.4T
> ```
> 上述示例将原来 Car 对象中的函数体的内容放到新建的 car 的 init 方法中，在使用 Car创建完 car 实例对象后，再调用 init 方法初始化，这种方式和前面例子中将初始化内容放到Car 的函数体内的效果是完全相同的。
> 需要特别注意的是，创建过程的第二步，也就是说，在使用 function 对象新建 object 对象时依然会执行 function 的函数体。 通过下面的例子可以更加直观地看到这一点。
> ```js
> var name＝"和坤"；
> function Sikuquanshu(){
> name＝"纪晓岚"；
> }
> console.log(name);  // 和神
> var skqs =new Sikuquanshu();
> console.log(name);  // 纪晓岚
> ```
> 这个例子中存在一个全局变量 name，原值为"和坤"，在函数 Sikuquanshu 内部将其改为"纪晓岚"，在上述代码中并没有直接执行此函数，但在使用它创建 skqs 对象时其函数体得到了执行，这从创建 skqs 对象前后打印出的内容就能看出来，全局变量 name 被修改了。在使用 function 对象创建实例对象时一定要注意这一点。
> 理解了对象创建的过程就可以理解为什么在构造函数（例如 Car）中使用 this 可以将属性添加到新创建的对象上。 
> 因为这时的函数体就相当于新创建的对象的一个方法，方法中的 this 指的就是新创建的对象自身，给 this 赋值就是给新创建的对象赋值，因此在 function对象中使用 this 就可以给新创建出来的对象添加属性，就像本书第一个例子中的 Car 方法的" this.color = color ；"语句，这条语句会给新创建的 car 对象添加 color 属性并将 color 参数的值赋给它。 

### 4.5 三种子类型
>  ES 中的 function 共有三种用法：作为对象使用、处理业务以及创建 object类型的实例对象。 跟这三种用法相对应的有三种子类型，分别是对象的属性、变量（包括参数）和创建出来的 object 类型实例对象的属性。这三种子类型是相互独立的，而且也很容易区分。

#### 4.5.1 function 作为对象来使用
> 这种情况下， function 对象的子类型就是对象自己的属性，这时通过点操作符"．"（或者方括号操作符）使用，例如下面的例子。
> ```js
> function book(){}
> book.price = 161.0;
> book.getPrice = function (){
>   return this.price;
> }
> console.log(book.getPrice()) ; //161
> ```
> 在这种情况下， function 是作为 object 类型的对象来使用的。上面的例子中首先定义了"nction 类型的 book 对象，然后给它添加了 price 属性和 getPrice 方法，这时就可以直接使用点操作符来对其进行操作了。

#### 4.5.2 function 用于处理业务
> 这种情况下， function 的子类型就是自己定义的局部变量（包括参数），这时的变量是在方法被调用时通过变量作用域链来管理的。

#### 4.5.3 function 用于创建对象
> 这种情况下，对应的子类型是使用 function 创建的实例对象的属性，主要包括在function 中通过 this 添加的属性，以及创建完成之后实例对象自己添加的属性。
> 另外，还可以调用 function 的 prototype 属性对象所包含的属性，例如前面用过的 Car 的例子。
> ```js
> function Car(color, displacement){
>   this.color = color;
>   this.displacement = displacement;
> }
> Car.prototype.logMessage = function(){
> console.log(this.color + "," + this.displacement);
> }
> var car = new Car("black","2.4T");
> ```
> 这个例子中创建的 car 对象就包含有 color 和 displacement 两个属性，而且还可以调用Car. prototype 的 logMessage 方法。 当然，创建完之后还可以使用点操作符给创建的 car 对象添加或者修改属性，也可以使用 delete 删除其中的属性，例如下面的例子。
> ```js
> function Car(color, displacement){
>   this.color = color;
>   this.displacement = displacement;
> }
> Car.prototype.logMessage = function(){
> console.log(this.color + ", " + this.displacement);
> }
> var car = new Car("black","2.4T");
> car.logColor = function (){
>   console.log(this.color);
> }
> car.logColor();     //black
> car.color ="red";   
> car.logColor();     //red
> delete car.color;
> car.logColor();     //undefined
> ```
> 这个例子中，在创建完 car 对象后又给它添加了 logColor 方法，可以打印出 car 的 color属性。 添加完 logColor 方法后直接调用就可以打印出 car 原来的 color 属性值（black ）。
> 然后，将其修改为 red，再打印就打印出了 red。 最后，使用 delete 删除 car 的 color 属性，这时再调用 logColor方法就会打印出 undefined。

#### 4.5.4 三种子类型的关系
> function 的三种子类型是相互独立的，它们只能在自己所对应的环境中使用而不能相五调用，例如下面的例子。
> ```js
> function log(msg){
>   console.log(msg);
> }
> function Bird(){
>   var name = "kitty";
>   this.type = " pigeon";
>   this.getName = function (){
>     return this.name;
>   }
> }
> Bird.color = "white ";
> Bird.getType = function (){
>   return this.type;
> }
> Bird.prototype.getColor = function (){
>   return this.color;
> }
> var bird = new Bird();
> log(bird.getColor());  //undefined
> log(bird.getName());   //undefined
> log(Bird.getType());   //undefined
> ```
> 这个例子中的最后三条语句都会打印出 undefined，下面分析其中的原因。
> Bird 作为对象时包含 color 和 getType 两个属性，作为处理业务的函数时包含一个名为name 的局部变量，创建的实例对象 bird 具有可pe 和 getName 两个属性，而且还可以调用Bird.prototype 中的 getColor 属性， getColor 也可以看作 bird 的属性.
> 除了三种子类型不可以相互调用之外，还有一种情况也非常容易被误解，那就是对象的属性并没有继承的关系，例如下面的例子。
> ```js
> function obj(){}
> obj.v = 1;
> obj.func = {
>   logV : function(){
>   console.log(this.v);
>   }
> }
> obj.func.logV();
> ```
> 这个例子中的 obj 是作为对象使用的， obj 有一个属性 v 和一个对象属性缸时， func 对象中又有一个 logV 方法， logV 方法用于打印对象的 v 属性。这里需要特别注意， logV 方法打印的是 func 对象的 v属性，但是旬nc 对象并没有 v 属性，所以最后会打印出 undefined。
> 在这个例子中，虽然 obj 对象中包含 v 属性，但是由于属性不可以继承，所以 obj 的"nc属性对象中的方法不可以使用 obj 中的属性 v。 这一点各位读者一定要记住，并且不要和prototype 的继承以及变量作用域链相混淆。

**JS 中的"公有属性" "私有属性" 和 "静态属性"**
> 在有些资料中，可能会看到类似"公有属性""私有属性"以及"静态属性"等名称，其实这些是基于类的语言（例如 Java、 C＋＋等）中的一些概念，由于 JS 并不是基于类的而是基于对象的语言，因此 JS 本身并没有这些概念。 
> 所谓的"公有属性"，一般指使用function 对象创建出来的 object 实例对象所拥有的属性，"私有属性"一般指 function 的内部变量，"静态属，｝生"一般指 function 对象自己的属性。 
> 这跟基于类的语言的公有属性、私有属性的含义并不相同，而且这种叫法很容易让人产生误解，其实这是三种不同用法分别对应的三种不同的子类型。

