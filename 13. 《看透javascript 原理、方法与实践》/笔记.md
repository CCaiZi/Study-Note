![《JavaScript编程全解》](.\images\《看透javascript%20原理、方法与实践》.jpg)

## 第 1 章 JavaScript 怎么学

#### 1.2.3 JavaScript 是一种事件驱动的语言
> 事件驱动是指 JavaScript 引擎并不是在看到代码之后就会立即执行，而是会在合适的时间才去执行。这个合适的时间是指当某个事件发生之后（例如一个输入框的内容发生了变化，这就是一个事件） 。 只有当相应的事件发生了之后，相应的操作才会执行，这就是事件驱动。

## 第 4 章 function 类型对象
#### 4.1.3 两种创建方式的关系
> 在 JS 中所有的数据只有两种存在形式，要么是对象的属性，要么是变量，函数也不例外，无论是对象的属性还是变量都是名值对的结构，因此函数也应该是这种名值对的结构，由函数表达式可以很容易看明白这一点。 
> 其实，通过函数声明方式创建函数时， JS 在背后自动帮用户做了这件事情，它首先创建了函数对象，然后又创建了跟函数名同名的变量，并将创建出来的函数赋值给了这个变量。 

### 4.3 处理业务
#### 4.3.2 操作符
> `>> 和 >>>`
> 这两个符号的作用都是右移位。 
> 在计算机中保存的数据（主要指整数）也像平时所写的数一样，除了数字本身外还有“位”的概念，例如4567 这个数的千位为 4，百位为 5 ，十位为 6，个位为 7，把不同的数字放到不同的位，其权重就不一样了。 
> 假如现在的数只有 4 位（就像某些需要填数字的单据上一格填一个数字，一共有 4 格，只能填 4 个数字），那么 4567 左移一位就是 5670，左移两位就是 6700，而右移一位就成了 0456，右移两位就成了 0045 。 
> 在计算机中的左移右移跟这里类似，只是它不一定是 4 位，而且每一位都只能是 0 或 1 。 
> 在程序中经常使用左移右移来做 2 的整数倍的乘除法，这就像十进制中左移一位扩大 10 倍右移一位缩小到原来的 1110 一样，不过左移右移要比乘除法的计算简单很多。 对于处理器来说也一样，移位要比计算乘除速度快。
> 不过计算机中的移位跟上述十进制的移位还是存在区别的。 
> 在计算机中因为只有 0 和 I'所以为了区分正负数，现有的做法是将负数用补码来表示，这样只要看最高位是 0 还是 I '就可以区分正负数了（这里只要知道有符号数将最高位用作符号位，符号位 0 表示正数，符号位 1 表示负数即可）。 但是这时候问题就来了，对于一个负数来说，右移一位后其符号位（最高位）正常应该变成 0，这样就变成正数了，此时就会出现问题了，因此在右移的时候对有符号数和无符号分别使用了不同的操作符。
> 当然，这只是表层的区别，在底层有符号数和无符号数使用的是两套不同的进位／溢出标志，例如 x86 处理器中有符号数用 OF，无符号数用 CF 标志。
>  另外，数据本身只是一串由0 和 1 组成的编码， 是无法区分有符号数还是无符号数的，只是人为将其看作有符号数或者无符号数而已（在程序的底层会通过类型标志进行区分）。 
> 对于一些强类型语言来说，在定义数据的时候就会指定数据的类型，这样在使用时，就可以清楚地知道应该将其看作有符号数还是无符号数。 
> 因为 JS 是一种弱类型语言，变量的类型可以任意转换，所以对于`-1>>>0`。这样的操作来说，操作的目标是表示 1 的一串数（对于 32 位数来说就是 OXFFFFFFFF，即 32个 I ），操作的过程是将其当作无符号数左移 0 位，这时虽然不会对数字本身做任何修改，但是，因为在操作的过程中已经将其看作无符号数，所以其结果也就变成了 4294967295，即无符号数的 32 个 1 ，同样这也是有符号数一l 的 32 位编码。

---

> **在 JS 申函敏是怎么执行的**
> 函数无非两部分：数据和对数据的操作。 数据又分为外部数据和内部数据，对于外部数据，本书将在后边的作用域链中进行介绍。 内部数据又分为参数和变量两部分。 在函数每次执行的时候参数都会被赋予一个新值，而变量则每次都会被设直为一个相同的初始值。
> 函数的变量和参数是怎么保存的呢？对于多个数据来说，最常用也是最简单的保存方式就是使用数组保存，这样按序号查找起来就非常方便了 。 
> 而且，一般来说，一个函数的参数和变量都会集中保存在一个数纽或者跟数纽类似的结构（例如裁）中。 但是，数组本身存在一个非常致命的缺点，它要求每个元素的长度都相等，这对于参数（或变量）来说是很难符合要求的。 
> 但是，为了使用数纽（或我）的便捷性通常会在数组中保存一个包含地址的数据（除地址外，还可能包含数据类型等其他数据），而不是实际的数据，这样既可以使用数组，又可以保存不同长度的数据。 
> 此时，在函数中使用参数（或变量）的时候只需要使用“第几个参数（或变量）”就可以了，至于数组中具体一个元素使用多少位，则需要根据不同的硬件平台（例如，是 32 位还是 64 位）和具体引擎的开发者来确定。 
> 但是，这里还存在一个小问题，对于复杂的数据来说，这样保存无可厚非，而对于直接使用数组元素就可以保存的简单数据（例如整数）来说，再使用这种方式就显得复杂了，而且多一步通过地址查找数据的操作也会影响效率，因此这种情况一般会直接将值保存到数组中，而不是保存地址。
> 函数在每次执行之前都会新建一个参数数组和一个变量数纽（当然也可以合并为一个数组，而且通常会使用我来实现），然后将调用时所传递的参数设直到参数数组中，而变量数组在每次执行前都具有相同的内容，对数据进行操作时只需要使用“第几个参数”或者“第几个变量”即可。
> 简单的数据（例如整数）会直接保存在数组中，而对于复杂的数据，数组中只保存地址，具体的数据保存在堆中 。 
> 可以简单地将堆理解为一堆草纸，其所保存的数据是所有函数所共享的，不过也并不是每个函数都可以调用堆中所有的数据。 因为调用堆中数据的前提是能找到，如果找不到当然也就调用不了 。 
> 例如，在函数中定义了一个字符串的对象变量 s，这时就会将 s 的内容保存到堆中，然后将堆中所保存数据的地址保存到函数的变量数组中，这时对于函数外部来说，虽然可以访问堆中的数据，但是因为没有s 的地址，所以也就无法访问 s 这个字符串变量了 。

#### 4.3.5 闭包
> ```js
> function fl() {
>   var v=l;
>   function f2() {
>     var vl = l;
>     console.log(v+”,”+vl);
>     v++;
>     vl++;
>     return f2;
> }
> var f = fl ();
> f();  //1 ,1
> f();  //2 ,1
> f();  //3 ,1
> ```
> 从上面的例子可以看出， fl 中定义的变量 v 在每次调用时会累加，这说明每次调用时使用的都是原来的数据，而口中定义的变量 vl 则在每次调用时都会创建新的数据。
> 其原理其实非常简单，在函数 fl 执行时会创建一套 fl 的变量数组，在函数口执行时会创建另外一套口的变量数组。 按照 JS 中变量作用域链的规则，在口中可以调用执行 fl 时所创建的变量数组，为了口可以正确执行，只要在口还可能被调用的时候执行 fl 时所创建的执行环境（包括变量数组）就不会被释放，因此， fl 中定义的变量 v 会使用同一个，而口每次执行完之后所创建的执行环境就没用了，会被释放，而在下次执行时又会创建新的执行环境。