![《JavaScript编程全解》](.\images\JavaScript编程全解.jpeg)

**本书以 ECMAScript 第5版为标准的 JavaScript 1.8.5**

## 第2章 JavaScript 的语言基础

### 2.1 JavaScript 的特点

JavaScript 程序设计语言有如下几个特点:

* 解释型语言
* 类似于 C 和 Java 的语法结构
* 基于原型的面向对象
* 字面量的表现能力
* 函数式编程

##### 解释型语言

> 和解释型语言相对应的是编译型语言。解释型语言直接在运行环境中执行代码，所以和编译型语言相比，解释型语言的开发更为容易。

> 解释型语言的劣势在于，其运行的速度通常都会慢于编译型语言

##### 动态语言

> 但从代码的角度看，动态语言的变量和函数是不指定返回值的类型。JavaScript 之所以被设计成动态语言，和选择其设计为解释型语言的理由一样，都是优先考虑了开发难易度的结果。

##### 基于原型的面向对象

> 基于原型的面向对象特性和基于类的面向对象的特性是有所差别的。

#### 2.4.1 函数的定义

> 函数是由一连串的子程序(语句的集合)所组成的，可以被外部程序调用。想函数传递参数后，函数可以返回一定的值。

> 通常情况下，JavaScript代码是自上而下执行的，不过函数体内部的代码则不是这样。如果只是对函数进行了声明，其中的代码并不会执行。只有在调用函数时才会执行函数体内部的代码。

## 第3章 JavaScript 的数据类型

#### 3.1.1 在数据类型方面与 Java 作比较

> 从两个不同的角度来讨论这些差别：其一是从动态数据类型和静态数据类型的角度；其二是从基于类和基于原型的角度。

##### 动态数据类型与静态数据类型

> 在 JavaScript 中，值和对象具有数据类型，而变量没有数据类型。事实上，JavaScript 中并不存在变量类型的概念。

> 与之相反，在 Java 语言中变量有类型之分。Java 中的变量有其数据类型，它限制了可以对该变量赋值的值和对象引用的类型。

> 因为JavaScript 的变量不具有数据类型，所有可以对其赋任意类型的值，也可以使其引用任意类型的对象。

> 像 Java 这样，变量具有数据类型的语言，被称为静态数据类型语言；而像 JavaScript 这样，变量没有类型，则被称为动态数据类型语言。

> 同理，对于 Java 和 JavaScript 中函数的参数和返回值，也存在类似的差别。

> JavaScript 的函数参数及返回值是不具有数据类型的。也就是说，静态数据类型和动态数据类型之间的差异在函数的类型中也会有所体现。

##### 基于类与基于原型

> 对于 Java 来说，内建类型 (int 或 double 之类) 之外的都是用户自定义类型。

> 而用户自定义类型又可以分为类和接口两种类型。即开发者需要书写该类型的定义语句来定义该类型。而对象则作为这些由用户定义的数据类型的实例(实体)存在。这种编码风格被称为基于类的语言风格。

> 在 JavaScript 的语言规范中，不存在定义数据类型的语句。不需要使用特别的语句就能定义一个对象的属性或方法，而这样也就决定了该对象的类型。所谓的类型也就是行为方式上的共性。由于每个对象都具有共同的行为方式，所以可以使用原型对象。这样的编码风格被称为基于原型的风格。

### 3.2 内建数据类型概要

> 在 ECMAScript 标准中，内建数据类型(built-in type) 分为5中基本数据类型以及 Object 类型。该标准中并没有原始类型 (primitive type, 也称为基本数据类型或是简单数据类型) 这样的术语，而是使用了原始值 (primitive value) 的名称。在本书中，为了便于理解，统一使用基本数据类型这一名称。

### 3.3 字符串型

#### 3.3.4  字符串类(String 类)

> 之前提到过，在 JavaScript 中字符串型是一种内建类型。不过 JavaScript 的字符串也有容易使人混淆的地方，即 **除了内建类型的字符串之外还存在一个字符串类**。

> 字符串类的名称为 String 。 JavaScript 中字符串型和 String 类的关系，大致相当于 Java 中数值型和包装型(Number 类和 Integer 类) 的关系。字符串型和 String 类之间也同样支持隐式类型转换。在 Java 中存在装箱和拆箱转换， 在 JavaScript 的字符串型和 String 类之间也有着类似的转换。这一转换通常是隐式进行的。

> 例如，可以像下面这样获取字符串的字数；

```js
var s = '012';
s.length;     // 在形式上类似于读取字符串制的属性

'012'.length; // 在形式上类似于读取字符串字面量的属性
```

> 上述代码中，其内部发生了字符串值到 String 对象 (**在本书中， String 类的实例被称为 String 对象或是字符串对象**) 的隐式数据类型转换。
> 表面上，后面两行代码执行结果一样，但两者在语法意义上是不同的。 `s.length` ，这里的点运算符的含义其实是一般意义上的对类方法的调用。
> `'012'.length` ,(属于内建类型的)字符串值会先被隐式的转换为字符串对象，然后再读取字符串对象的 `length` 属性。

#### 3.3.6 避免混用字符串值和字符串对象

> 要防止混用字符串值和字符串对象是很简单的，只要不显示的使用 `new String()` 即可。也就是说，应该避免显示的生产字符串对象。
> 需要使用字符串值的时候，一般都使用字符串字面量。对于其他情况，通过 String 函数进行显示的数据类型转换就足够了。
> 避免显示的生成字符串对象并不意味着要避免使用字符串对象，应该是积极的使用隐式数据类型变化，将字符串值转化为字符串对象。

#### 3.3.9 非破坏性的方法

> 字符串对象和字符串值一样，是不可变的。也就是说不能改写字符串的内容。所以要改变字符串内容的方法，都会生成一个新的字符串对象然后将其返回。

```js
var s = new String('abc');

var s2 = s.toUpperCase(); 
console.log(s, s2);     // 对象 s 的内容不发生变化

// =>abc ABC

s[0] = 'A';             // 即使使用 [] 运算也不会改变字符串的内容
console.log(s);  
// => abc       
```

### 3.6 null 型

> null 值是一个字面量。

### 3.7 undefined 型
> undefined 型只能够取 undefined 值；它不是字面量，而是一个预定义的全局变量。

##### undefined 值
> 出现 undefined 值的情况：
> * 未初始化的变量的值
> * 不存在的属性的值
> * 在没有传入实参而调用函数时，该函数内相应参数的值
> * 没有 `return` 语句，或是 `return` 语句中不含表达式的函数的返回值
> * 对 `void` 运算符求值的结果(常常会通过使用 `void 0` 来获取一个 `undefined` 值)

### 3.9 数据类型转换

#### 3.9.4 转换为布尔值
> 出下面5种情况外，都被转为 `true`
> * 数值 0
> * 数值 NaN
> * null 值
> * undefined 值
> * 字符串值 "" (空字符串值)

> 在进行布尔型的数据类型转换时，应当对 Object 类型的情况多加注意。
> Object 类型在被转换为布尔型之后，结果必定为 `true`。 
> 以下代码的结构都显示 T。这和直观的感觉是有所不同的，请务必注意：
```js
var b = new Boolean(false);
if(b){
  console.log('T');   // => T
}else{
  console.log('F');
}

var z = new Number(0);
if(z){
  console.log('T');   // => T
}else{
  console.log('F');
}

var s = new String('');
if(s){
  console.log('T');   // => T
}else{
  console.log('F');
}
```

> 像下面这样，通过函数调用方式获得的结果就不再是 Object 类型，而是相应的内建类型了。这样一来，转换的结果就会与直觉一致。
```js
var b = Boolean(false);
if(b){
  console.log('T');
}else{
  console.log('F');   // => F
}

var z = Number(0);
if(z){
  console.log('T'); 
}else{
  console.log('F');   // => F
}

var s = String('');
if(s){
  console.log('T');
}else{
  console.log('F');   // => F
}
```

## 第4章 语句、表达式和运算符
### 4.4 字面量
> 字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。
> 也许你会觉得，在代码中书写的值自然会在运行时按原样表达该值，不过事实上并非如此；
> ```js
> // 字符串字面量 'bar' 的例子
> var foo = 'bar';
> ```
> 根据语法规则，代码中的 `var` 这个词的含义是变量的声明，因此，在运行中 `var` 并不会被识别为一个内容为 `var` 的单词。
> 类似的，`foo` 这个词在运行时也不会被识别为一个内容为 foo 的单词，而仅被认为是变量 foo 所表示的值。
> 另一方面， `'bar'` 是一个字符串字面量，所以 bar 这一单词在运行过程中的含义就是 bar 这一字符序列而已。

### 4.18 for in 语句
#### 4.18.2 在使用 for in 语句需要注意的地方
> 有3点需要注意：
> **枚举属性的顺序**
> 由于属性之间不存在顺序关系，所以不一定会通过对象字面量书写的顺序来进行枚举；
> 另一方面，数列是一种有顺序关系的数据类型。虽然可能绝大多数时候能够按照预期顺序输出，不过 for in 语句本身并不保证会按照某一顺序枚举。
> **无法被枚举的属性**
> 有一些属性是不能够被 for in 语句枚举的。比如，数列对象中的 length 属性。
> **由原型继承而来的属性**
> for in 语句还可以枚举由原型继承而来的属性。  

### 4.33 相等运算符
> 相等运算符会进行隐式转换，规则如下：
> * x 与 y 的数据类型相同，与全等运算符的结果相同
> * x 与 y 的数据类型不同，规则如下：
>> * 1.一方为 null 值时，另一方为 undefined 值的情况，结果为真
>> * 2.一方为数值，另一方为字符串值，将字符串值转换为数值之后再进行数值比较
>> * 3.一方为布尔值，另一方为字符串值，将两者都转换为数值后对数值进行比较
>> * 4.一方为布尔值，另一方为数值，将布尔值转换为数值后对数值进行比较
>> * 5.一方为数值，另一方为对象引用，将对象转换为数值后对数值进行比较
>> * 6.一方为字符串值，另一方为对象引用，将对象引用转换为字符串值后对字符串内容进行比较
>> * 7.以上6种情况之外的运算结果都为假