![《JavaScript编程全解》](.\images\JavaScript编程全解.jpeg)

**本书以 ECMAScript 第5版为标准的 JavaScript 1.8.5**

## 第2章 JavaScript 的语言基础

### 2.1 JavaScript 的特点

JavaScript 程序设计语言有如下几个特点:

* 解释型语言
* 类似于 C 和 Java 的语法结构
* 基于原型的面向对象
* 字面量的表现能力
* 函数式编程

##### 解释型语言

> 和解释型语言相对应的是编译型语言。解释型语言直接在运行环境中执行代码，所以和编译型语言相比，解释型语言的开发更为容易。

> 解释型语言的劣势在于，其运行的速度通常都会慢于编译型语言

##### 动态语言

> 但从代码的角度看，动态语言的变量和函数是不指定返回值的类型。JavaScript 之所以被设计成动态语言，和选择其设计为解释型语言的理由一样，都是优先考虑了开发难易度的结果。

##### 基于原型的面向对象

> 基于原型的面向对象特性和基于类的面向对象的特性是有所差别的。

#### 2.4.1 函数的定义

> 函数是由一连串的子程序(语句的集合)所组成的，可以被外部程序调用。想函数传递参数后，函数可以返回一定的值。

> 通常情况下，JavaScript代码是自上而下执行的，不过函数体内部的代码则不是这样。如果只是对函数进行了声明，其中的代码并不会执行。只有在调用函数时才会执行函数体内部的代码。

## 第3章 JavaScript 的数据类型

#### 3.1.1 在数据类型方面与 Java 作比较

> 从两个不同的角度来讨论这些差别：其一是从动态数据类型和静态数据类型的角度；其二是从基于类和基于原型的角度。

##### 动态数据类型与静态数据类型

> 在 JavaScript 中，值和对象具有数据类型，而变量没有数据类型。事实上，JavaScript 中并不存在变量类型的概念。

> 与之相反，在 Java 语言中变量有类型之分。Java 中的变量有其数据类型，它限制了可以对该变量赋值的值和对象引用的类型。

> 因为JavaScript 的变量不具有数据类型，所有可以对其赋任意类型的值，也可以使其引用任意类型的对象。

> 像 Java 这样，变量具有数据类型的语言，被称为静态数据类型语言；而像 JavaScript 这样，变量没有类型，则被称为动态数据类型语言。

> 同理，对于 Java 和 JavaScript 中函数的参数和返回值，也存在类似的差别。

> JavaScript 的函数参数及返回值是不具有数据类型的。也就是说，静态数据类型和动态数据类型之间的差异在函数的类型中也会有所体现。

##### 基于类与基于原型

> 对于 Java 来说，内建类型 (int 或 double 之类) 之外的都是用户自定义类型。

> 而用户自定义类型又可以分为类和接口两种类型。即开发者需要书写该类型的定义语句来定义该类型。而对象则作为这些由用户定义的数据类型的实例(实体)存在。这种编码风格被称为基于类的语言风格。

> 在 JavaScript 的语言规范中，不存在定义数据类型的语句。不需要使用特别的语句就能定义一个对象的属性或方法，而这样也就决定了该对象的类型。所谓的类型也就是行为方式上的共性。由于每个对象都具有共同的行为方式，所以可以使用原型对象。这样的编码风格被称为基于原型的风格。

### 3.2 内建数据类型概要

> 在 ECMAScript 标准中，内建数据类型(built-in type) 分为5中基本数据类型以及 Object 类型。该标准中并没有原始类型 (primitive type, 也称为基本数据类型或是简单数据类型) 这样的术语，而是使用了原始值 (primitive value) 的名称。在本书中，为了便于理解，统一使用基本数据类型这一名称。

### 3.3 字符串型

#### 3.3.4  字符串类(String 类)

> 之前提到过，在 JavaScript 中字符串型是一种内建类型。不过 JavaScript 的字符串也有容易使人混淆的地方，即 **除了内建类型的字符串之外还存在一个字符串类**。

> 字符串类的名称为 String 。 JavaScript 中字符串型和 String 类的关系，大致相当于 Java 中数值型和包装型(Number 类和 Integer 类) 的关系。字符串型和 String 类之间也同样支持隐式类型转换。在 Java 中存在装箱和拆箱转换， 在 JavaScript 的字符串型和 String 类之间也有着类似的转换。这一转换通常是隐式进行的。

> 例如，可以像下面这样获取字符串的字数；

```js
var s = '012';
s.length;     // 在形式上类似于读取字符串制的属性

'012'.length; // 在形式上类似于读取字符串字面量的属性
```

> 上述代码中，其内部发生了字符串值到 String 对象 (**在本书中， String 类的实例被称为 String 对象或是字符串对象**) 的隐式数据类型转换。
> 表面上，后面两行代码执行结果一样，但两者在语法意义上是不同的。 `s.length` ，这里的点运算符的含义其实是一般意义上的对类方法的调用。
> `'012'.length` ,(属于内建类型的)字符串值会先被隐式的转换为字符串对象，然后再读取字符串对象的 `length` 属性。

#### 3.3.6 避免混用字符串值和字符串对象

> 要防止混用字符串值和字符串对象是很简单的，只要不显示的使用 `new String()` 即可。也就是说，应该避免显示的生产字符串对象。
> 需要使用字符串值的时候，一般都使用字符串字面量。对于其他情况，通过 String 函数进行显示的数据类型转换就足够了。
> 避免显示的生成字符串对象并不意味着要避免使用字符串对象，应该是积极的使用隐式数据类型变化，将字符串值转化为字符串对象。

#### 3.3.9 非破坏性的方法

> 字符串对象和字符串值一样，是不可变的。也就是说不能改写字符串的内容。所以要改变字符串内容的方法，都会生成一个新的字符串对象然后将其返回。

```js
var s = new String('abc');

var s2 = s.toUpperCase(); 
console.log(s, s2);     // 对象 s 的内容不发生变化

// =>abc ABC

s[0] = 'A';             // 即使使用 [] 运算也不会改变字符串的内容
console.log(s);  
// => abc       
```

### 3.6 null 型

> null 值是一个字面量。

### 3.7 undefined 型
> undefined 型只能够取 undefined 值；它不是字面量，而是一个预定义的全局变量。

##### undefined 值
> 出现 undefined 值的情况：
> * 未初始化的变量的值
> * 不存在的属性的值
> * 在没有传入实参而调用函数时，该函数内相应参数的值
> * 没有 `return` 语句，或是 `return` 语句中不含表达式的函数的返回值
> * 对 `void` 运算符求值的结果(常常会通过使用 `void 0` 来获取一个 `undefined` 值)

### 3.9 数据类型转换

#### 3.9.4 转换为布尔值
> 出下面5种情况外，都被转为 `true`
> * 数值 0
> * 数值 NaN
> * null 值
> * undefined 值
> * 字符串值 "" (空字符串值)

> 在进行布尔型的数据类型转换时，应当对 Object 类型的情况多加注意。
> Object 类型在被转换为布尔型之后，结果必定为 `true`。 
> 以下代码的结构都显示 T。这和直观的感觉是有所不同的，请务必注意：
```js
var b = new Boolean(false);
if(b){
  console.log('T');   // => T
}else{
  console.log('F');
}

var z = new Number(0);
if(z){
  console.log('T');   // => T
}else{
  console.log('F');
}

var s = new String('');
if(s){
  console.log('T');   // => T
}else{
  console.log('F');
}
```

> 像下面这样，通过函数调用方式获得的结果就不再是 Object 类型，而是相应的内建类型了。这样一来，转换的结果就会与直觉一致。
```js
var b = Boolean(false);
if(b){
  console.log('T');
}else{
  console.log('F');   // => F
}

var z = Number(0);
if(z){
  console.log('T'); 
}else{
  console.log('F');   // => F
}

var s = String('');
if(s){
  console.log('T');
}else{
  console.log('F');   // => F
}
```

## 第4章 语句、表达式和运算符
### 4.4 字面量
> 字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。
> 也许你会觉得，在代码中书写的值自然会在运行时按原样表达该值，不过事实上并非如此；
> ```js
> // 字符串字面量 'bar' 的例子
> var foo = 'bar';
> ```
> 根据语法规则，代码中的 `var` 这个词的含义是变量的声明，因此，在运行中 `var` 并不会被识别为一个内容为 `var` 的单词。
> 类似的，`foo` 这个词在运行时也不会被识别为一个内容为 foo 的单词，而仅被认为是变量 foo 所表示的值。
> 另一方面， `'bar'` 是一个字符串字面量，所以 bar 这一单词在运行过程中的含义就是 bar 这一字符序列而已。

### 4.18 for in 语句
#### 4.18.2 在使用 for in 语句需要注意的地方
> 有3点需要注意：
> **枚举属性的顺序**
> 由于属性之间不存在顺序关系，所以不一定会通过对象字面量书写的顺序来进行枚举；
> 另一方面，数列是一种有顺序关系的数据类型。虽然可能绝大多数时候能够按照预期顺序输出，不过 for in 语句本身并不保证会按照某一顺序枚举。
> **无法被枚举的属性**
> 有一些属性是不能够被 for in 语句枚举的。比如，数列对象中的 length 属性。
> **由原型继承而来的属性**
> for in 语句还可以枚举由原型继承而来的属性。  

### 4.33 相等运算符
> 相等运算符会进行隐式转换，规则如下：
> * x 与 y 的数据类型相同，与全等运算符的结果相同
> * x 与 y 的数据类型不同，规则如下：
>> * 1.一方为 null 值时，另一方为 undefined 值的情况，结果为真
>> * 2.一方为数值，另一方为字符串值，将字符串值转换为数值之后再进行数值比较
>> * 3.一方为布尔值，另一方为字符串值，将两者都转换为数值后对数值进行比较
>> * 4.一方为布尔值，另一方为数值，将布尔值转换为数值后对数值进行比较
>> * 5.一方为数值，另一方为对象引用，将对象转换为数值后对数值进行比较
>> * 6.一方为字符串值，另一方为对象引用，将对象引用转换为字符串值后对字符串内容进行比较
>> * 7.以上6种情况之外的运算结果都为假

### 4.34 比较运算符
> 如果两个操作数的类型不同，遵循以下规则：
> * 1.一方为数值，另一方为可以被转换为数值的数据类型的情况，将其转换为数值类型后再进行大小比较；
> * 2.如果操作数中含有 NaN 则结果为假；
> * 3.一方为字符串值，另一方为可以被转换为字符串值的数据类型的情况，将其转换为字符串值后再对字符串值进行大小比较；
> * 4.操作数中有无法被转换为数值及字符串值的值，或是转换结果为 NaN 的情况，运行结果为假；

## 第5章 变量与对象
### 5.1 变量的声明

> ```js
> var a = a || 7;   // 一种习惯的用法；如果变量a已经具有某个值(严格来说是具有某个可以被转为true的值)就直接使用，否则就把7赋值给a
> ```

### 5.2 变量与引用
> 对象的概念很好的说明了变量是一种拥有名称的客体。对象本身是没有名称的，之所以使用变量，是为了通过某个名称来称呼这样一种不具有名称的对象。
> 变量又分为基本类型的变量(值型变量)与引用类型的变量。由于在 JavaScript 中，变量是不具有类型的，因此从语法标准来看，两者并没有什么不同。不过，在 JavaScript 中仍然有对象的引用这一概念。
> 所谓"引用"，可以认为是一种用于指示出对象的位置的标记。引用这一语言功能只有指示位置信息的作用。准确的说，对象的赋值其实是将对象的引用进行赋值。

### 5.3 函数的参数(值的传递)
> **一个无法交换其两参数的值的函数**
> ```js
> function no_swap(a, b){
>  var tmp = a;
> a = b;
> b = tmp;
> }
>
> var one = 1;
> var zero = 0;
> no_swap(one, zero);     // 变量 one 与 zero 的值没有发生改变
> console.log(one, zero); // 1 0  
> ```

> 虽然变量 one 与 zero 是基本类型的变量，但实际上也只是对其引用了复制操作；因此，无法实现对 one 与 zero 的值进行交换。

> 以下代码可以实现
> ```js
> function swap(a, b){
> return [b, a];
> }
> 
> var one = 1;
> var zero = 0;
> [one,zero]=no_swap(one, zero);
> console.log(one, zero);   // 0 1
> ```

#### 5.2.2 字符串与引用
> 将字符串值赋值给变量时，究竟是复制字符串的值，还是赋值其引用呢?
> 字符串型是一种基本数据类型，根据语法规则，对其值本身进行复制时对一致性的要求更高。
> 同时，由于比较运算判断的正是字符串的内容是否一致，所以将其认为是一种值也会更加容易理解。
> 然而，在具体实现语言时，几乎所有的 JavaScript 实现都采用了引用复制的方式。这是因为，如果在变量赋值时进行字符串值的复制，效率将变得非常低。
> 那么，是否可以把字符串型看作一种引用类型呢?答案是肯定的，将其看作值类型也好，引用类型也好，都不会有问题，因为字符串型是一种不可变类型。由于字符串值是无法改变的，因此无论是对其值本身进行复制还是对其引用进行复制，表面上并不会有什么区别。
> 总而言之，即使字符串型在内部是以引用类型的方式实现的，从语言规则上来看，它仍然是一种值的类型。

#### 5.2.3 对象与引用相关的术语总结

> 在将对象的引用赋值给变量a时，这个对象将被称作“对象a”。这种称法，会给读者一种（本应不具有名字的）对象其实具有a这样一个名称的感觉。
> 显然这样的感觉是不正确的，因为这个对象即使在没有变量a的情况下，也能够独立存在。这样说的证据是，如果将变量a消去，或是将变量a指向其他的对象，原来的这个对象仍然会存在 。话虽如此，每次都很准确地使用“变量a所引用的对象”这样的说法过于冗长，所以方便起见，还是称其为对象a。
> 此外，在上下文不会发生误会的情况下，可以用“对象”这一术语来指代“对象的引用”。对象是一个实体，而引用是用于指示这一实体的位置信息，两者本应是不同的。不过根据上下文可以知道， “将对象赋值给变量a”的说法很显然是指将对象的引用赋值，所以方便起见可以直接这么说。

### 5.3 变量与属性
> 在函数内声明的变量是局部变量。作为函数参数的参数变量也是一种局部变量。
> 局部变量是在调用函数时被隐式生成的对象的属性。被隐式生成的对象称为 Call 对象。

### 5.5 对变量是否存在的检验
> 如果试图读取没有被声明的变量，则会引起RetftrenceEror异常，这是一种错误，必须对代码进行修正。
> ```js
> var a = a || 7;  // 一种习惯用法。如果变量a已经具有某值，则使用变量a的值
> ```
> 该代码利用了对已经声明的变量再次声明不会产生副作用的特性。像下面这样，分成两行并使用不同的变量，作用是一样的。
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（1）
> var a;
> var b = a || 7;
> ```
> 准确地说，这一代码并没有判断变量a是否已经被声明。例如在该例中，如果变量a的值是0或者是" （空字符），它在被转换为布尔型之后值就会为假，这时，代码中的变量b则会被赋值为7.
> 接下来的代码可能有些冗长，它直接判断变量a的值是否是undefined值，由此判断出变量a是否巴声明，或者是否在声明后值为undefined.
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（2）
> var a;
> var b=a Is undefined ? a: 7;
>```
> 虽说对同一变量再次声明不会有副作用，但每次都要写一遍var a也有些麻烦。为了避免这一问题可以通过typeof运算来判断是否为undefined值

> 这个例子利用了在JavaScript （ ECMAScript）中没有块级作用域的特性
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（3）
> // （不使用var a的版本1
> if (typeof a l=s 'undefined) (
>  var b = a;
> } else {
>  var b = 7;
> }
> //从这里开始可以使用变量b
> ```
> 在以上这些代码中，无法区分变量a是还没声明，还是已经声明但值为undefined.