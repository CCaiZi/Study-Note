![《JavaScript编程全解》](.\images\JavaScript编程全解.jpeg)

**本书以 ECMAScript 第5版为标准的 JavaScript 1.8.5**

## 第2章 JavaScript 的语言基础

### 2.1 JavaScript 的特点

JavaScript 程序设计语言有如下几个特点:

* 解释型语言
* 类似于 C 和 Java 的语法结构
* 基于原型的面向对象
* 字面量的表现能力
* 函数式编程

##### 解释型语言

> 和解释型语言相对应的是编译型语言。解释型语言直接在运行环境中执行代码，所以和编译型语言相比，解释型语言的开发更为容易。

> 解释型语言的劣势在于，其运行的速度通常都会慢于编译型语言

##### 动态语言

> 但从代码的角度看，动态语言的变量和函数是不指定返回值的类型。JavaScript 之所以被设计成动态语言，和选择其设计为解释型语言的理由一样，都是优先考虑了开发难易度的结果。

##### 基于原型的面向对象

> 基于原型的面向对象特性和基于类的面向对象的特性是有所差别的。

#### 2.4.1 函数的定义

> 函数是由一连串的子程序(语句的集合)所组成的，可以被外部程序调用。想函数传递参数后，函数可以返回一定的值。

> 通常情况下，JavaScript代码是自上而下执行的，不过函数体内部的代码则不是这样。如果只是对函数进行了声明，其中的代码并不会执行。只有在调用函数时才会执行函数体内部的代码。

## 第3章 JavaScript 的数据类型

#### 3.1.1 在数据类型方面与 Java 作比较

> 从两个不同的角度来讨论这些差别：其一是从动态数据类型和静态数据类型的角度；其二是从基于类和基于原型的角度。

##### 动态数据类型与静态数据类型

> 在 JavaScript 中，值和对象具有数据类型，而变量没有数据类型。事实上，JavaScript 中并不存在变量类型的概念。

> 与之相反，在 Java 语言中变量有类型之分。Java 中的变量有其数据类型，它限制了可以对该变量赋值的值和对象引用的类型。

> 因为JavaScript 的变量不具有数据类型，所有可以对其赋任意类型的值，也可以使其引用任意类型的对象。

> 像 Java 这样，变量具有数据类型的语言，被称为静态数据类型语言；而像 JavaScript 这样，变量没有类型，则被称为动态数据类型语言。

> 同理，对于 Java 和 JavaScript 中函数的参数和返回值，也存在类似的差别。

> JavaScript 的函数参数及返回值是不具有数据类型的。也就是说，静态数据类型和动态数据类型之间的差异在函数的类型中也会有所体现。

##### 基于类与基于原型

> 对于 Java 来说，内建类型 (int 或 double 之类) 之外的都是用户自定义类型。

> 而用户自定义类型又可以分为类和接口两种类型。即开发者需要书写该类型的定义语句来定义该类型。而对象则作为这些由用户定义的数据类型的实例(实体)存在。这种编码风格被称为基于类的语言风格。

> 在 JavaScript 的语言规范中，不存在定义数据类型的语句。不需要使用特别的语句就能定义一个对象的属性或方法，而这样也就决定了该对象的类型。所谓的类型也就是行为方式上的共性。由于每个对象都具有共同的行为方式，所以可以使用原型对象。这样的编码风格被称为基于原型的风格。

### 3.2 内建数据类型概要

> 在 ECMAScript 标准中，内建数据类型(built-in type) 分为5中基本数据类型以及 Object 类型。该标准中并没有原始类型 (primitive type, 也称为基本数据类型或是简单数据类型) 这样的术语，而是使用了原始值 (primitive value) 的名称。在本书中，为了便于理解，统一使用基本数据类型这一名称。

### 3.3 字符串型

#### 3.3.4  字符串类(String 类)

> 之前提到过，在 JavaScript 中字符串型是一种内建类型。不过 JavaScript 的字符串也有容易使人混淆的地方，即 **除了内建类型的字符串之外还存在一个字符串类**。

> 字符串类的名称为 String 。 JavaScript 中字符串型和 String 类的关系，大致相当于 Java 中数值型和包装型(Number 类和 Integer 类) 的关系。字符串型和 String 类之间也同样支持隐式类型转换。在 Java 中存在装箱和拆箱转换， 在 JavaScript 的字符串型和 String 类之间也有着类似的转换。这一转换通常是隐式进行的。

> 例如，可以像下面这样获取字符串的字数；

```js
var s = '012';
s.length;     // 在形式上类似于读取字符串制的属性

'012'.length; // 在形式上类似于读取字符串字面量的属性
```

> 上述代码中，其内部发生了字符串值到 String 对象 (**在本书中， String 类的实例被称为 String 对象或是字符串对象**) 的隐式数据类型转换。
> 表面上，后面两行代码执行结果一样，但两者在语法意义上是不同的。 `s.length` ，这里的点运算符的含义其实是一般意义上的对类方法的调用。
> `'012'.length` ,(属于内建类型的)字符串值会先被隐式的转换为字符串对象，然后再读取字符串对象的 `length` 属性。

#### 3.3.6 避免混用字符串值和字符串对象

> 要防止混用字符串值和字符串对象是很简单的，只要不显示的使用 `new String()` 即可。也就是说，应该避免显示的生产字符串对象。
> 需要使用字符串值的时候，一般都使用字符串字面量。对于其他情况，通过 String 函数进行显示的数据类型转换就足够了。
> 避免显示的生成字符串对象并不意味着要避免使用字符串对象，应该是积极的使用隐式数据类型变化，将字符串值转化为字符串对象。

#### 3.3.9 非破坏性的方法

> 字符串对象和字符串值一样，是不可变的。也就是说不能改写字符串的内容。所以要改变字符串内容的方法，都会生成一个新的字符串对象然后将其返回。

```js
var s = new String('abc');

var s2 = s.toUpperCase(); 
console.log(s, s2);     // 对象 s 的内容不发生变化

// =>abc ABC

s[0] = 'A';             // 即使使用 [] 运算也不会改变字符串的内容
console.log(s);  
// => abc       
```

### 3.6 null 型

> null 值是一个字面量。

### 3.7 undefined 型
> undefined 型只能够取 undefined 值；它不是字面量，而是一个预定义的全局变量。

##### undefined 值
> 出现 undefined 值的情况：
> * 未初始化的变量的值
> * 不存在的属性的值
> * 在没有传入实参而调用函数时，该函数内相应参数的值
> * 没有 `return` 语句，或是 `return` 语句中不含表达式的函数的返回值
> * 对 `void` 运算符求值的结果(常常会通过使用 `void 0` 来获取一个 `undefined` 值)

### 3.9 数据类型转换

#### 3.9.4 转换为布尔值
> 出下面5种情况外，都被转为 `true`
> * 数值 0
> * 数值 NaN
> * null 值
> * undefined 值
> * 字符串值 "" (空字符串值)

> 在进行布尔型的数据类型转换时，应当对 Object 类型的情况多加注意。
> Object 类型在被转换为布尔型之后，结果必定为 `true`。 
> 以下代码的结构都显示 T。这和直观的感觉是有所不同的，请务必注意：
```js
var b = new Boolean(false);
if(b){
  console.log('T');   // => T
}else{
  console.log('F');
}

var z = new Number(0);
if(z){
  console.log('T');   // => T
}else{
  console.log('F');
}

var s = new String('');
if(s){
  console.log('T');   // => T
}else{
  console.log('F');
}
```

> 像下面这样，通过函数调用方式获得的结果就不再是 Object 类型，而是相应的内建类型了。这样一来，转换的结果就会与直觉一致。
```js
var b = Boolean(false);
if(b){
  console.log('T');
}else{
  console.log('F');   // => F
}

var z = Number(0);
if(z){
  console.log('T'); 
}else{
  console.log('F');   // => F
}

var s = String('');
if(s){
  console.log('T');
}else{
  console.log('F');   // => F
}
```

## 第4章 语句、表达式和运算符
### 4.4 字面量
> 字面量(literal)指的是，在代码中写下这些值之后，将会在运行时直接使用这些值的字面含义。
> 也许你会觉得，在代码中书写的值自然会在运行时按原样表达该值，不过事实上并非如此；
> ```js
> // 字符串字面量 'bar' 的例子
> var foo = 'bar';
> ```
> 根据语法规则，代码中的 `var` 这个词的含义是变量的声明，因此，在运行中 `var` 并不会被识别为一个内容为 `var` 的单词。
> 类似的，`foo` 这个词在运行时也不会被识别为一个内容为 foo 的单词，而仅被认为是变量 foo 所表示的值。
> 另一方面， `'bar'` 是一个字符串字面量，所以 bar 这一单词在运行过程中的含义就是 bar 这一字符序列而已。

### 4.18 for in 语句
#### 4.18.2 在使用 for in 语句需要注意的地方
> 有3点需要注意：
> **枚举属性的顺序**
> 由于属性之间不存在顺序关系，所以不一定会通过对象字面量书写的顺序来进行枚举；
> 另一方面，数列是一种有顺序关系的数据类型。虽然可能绝大多数时候能够按照预期顺序输出，不过 for in 语句本身并不保证会按照某一顺序枚举。
> **无法被枚举的属性**
> 有一些属性是不能够被 for in 语句枚举的。比如，数列对象中的 length 属性。
> **由原型继承而来的属性**
> for in 语句还可以枚举由原型继承而来的属性。  

### 4.33 相等运算符
> 相等运算符会进行隐式转换，规则如下：
> * x 与 y 的数据类型相同，与全等运算符的结果相同
> * x 与 y 的数据类型不同，规则如下：
>> * 1.一方为 null 值时，另一方为 undefined 值的情况，结果为真
>> * 2.一方为数值，另一方为字符串值，将字符串值转换为数值之后再进行数值比较
>> * 3.一方为布尔值，另一方为字符串值，将两者都转换为数值后对数值进行比较
>> * 4.一方为布尔值，另一方为数值，将布尔值转换为数值后对数值进行比较
>> * 5.一方为数值，另一方为对象引用，将对象转换为数值后对数值进行比较
>> * 6.一方为字符串值，另一方为对象引用，将对象引用转换为字符串值后对字符串内容进行比较
>> * 7.以上6种情况之外的运算结果都为假

### 4.34 比较运算符
> 如果两个操作数的类型不同，遵循以下规则：
> * 1.一方为数值，另一方为可以被转换为数值的数据类型的情况，将其转换为数值类型后再进行大小比较；
> * 2.如果操作数中含有 NaN 则结果为假；
> * 3.一方为字符串值，另一方为可以被转换为字符串值的数据类型的情况，将其转换为字符串值后再对字符串值进行大小比较；
> * 4.操作数中有无法被转换为数值及字符串值的值，或是转换结果为 NaN 的情况，运行结果为假；

## 第5章 变量与对象
### 5.1 变量的声明

> ```js
> var a = a || 7;   // 一种习惯的用法；如果变量a已经具有某个值(严格来说是具有某个可以被转为true的值)就直接使用，否则就把7赋值给a
> ```

### 5.2 变量与引用
> 对象的概念很好的说明了变量是一种拥有名称的客体。对象本身是没有名称的，之所以使用变量，是为了通过某个名称来称呼这样一种不具有名称的对象。
> 变量又分为基本类型的变量(值型变量)与引用类型的变量。由于在 JavaScript 中，变量是不具有类型的，因此从语法标准来看，两者并没有什么不同。不过，在 JavaScript 中仍然有对象的引用这一概念。
> 所谓"引用"，可以认为是一种用于指示出对象的位置的标记。引用这一语言功能只有指示位置信息的作用。准确的说，对象的赋值其实是将对象的引用进行赋值。

### 5.3 函数的参数(值的传递)
> **一个无法交换其两参数的值的函数**
> ```js
> function no_swap(a, b){
>  var tmp = a;
> a = b;
> b = tmp;
> }
>
> var one = 1;
> var zero = 0;
> no_swap(one, zero);     // 变量 one 与 zero 的值没有发生改变
> console.log(one, zero); // 1 0  
> ```

> 虽然变量 one 与 zero 是基本类型的变量，但实际上也只是对其引用了复制操作；因此，无法实现对 one 与 zero 的值进行交换。

> 以下代码可以实现
> ```js
> function swap(a, b){
> return [b, a];
> }
> 
> var one = 1;
> var zero = 0;
> [one,zero]=no_swap(one, zero);
> console.log(one, zero);   // 0 1
> ```

#### 5.2.2 字符串与引用
> 将字符串值赋值给变量时，究竟是复制字符串的值，还是赋值其引用呢?
> 字符串型是一种基本数据类型，根据语法规则，对其值本身进行复制时对一致性的要求更高。
> 同时，由于比较运算判断的正是字符串的内容是否一致，所以将其认为是一种值也会更加容易理解。
> 然而，在具体实现语言时，几乎所有的 JavaScript 实现都采用了引用复制的方式。这是因为，如果在变量赋值时进行字符串值的复制，效率将变得非常低。
> 那么，是否可以把字符串型看作一种引用类型呢?答案是肯定的，将其看作值类型也好，引用类型也好，都不会有问题，因为字符串型是一种不可变类型。由于字符串值是无法改变的，因此无论是对其值本身进行复制还是对其引用进行复制，表面上并不会有什么区别。
> 总而言之，即使字符串型在内部是以引用类型的方式实现的，从语言规则上来看，它仍然是一种值的类型。

#### 5.2.3 对象与引用相关的术语总结

> 在将对象的引用赋值给变量a时，这个对象将被称作“对象a”。这种称法，会给读者一种（本应不具有名字的）对象其实具有a这样一个名称的感觉。
> 显然这样的感觉是不正确的，因为这个对象即使在没有变量a的情况下，也能够独立存在。这样说的证据是，如果将变量a消去，或是将变量a指向其他的对象，原来的这个对象仍然会存在 。话虽如此，每次都很准确地使用“变量a所引用的对象”这样的说法过于冗长，所以方便起见，还是称其为对象a。
> 此外，在上下文不会发生误会的情况下，可以用“对象”这一术语来指代“对象的引用”。对象是一个实体，而引用是用于指示这一实体的位置信息，两者本应是不同的。不过根据上下文可以知道， “将对象赋值给变量a”的说法很显然是指将对象的引用赋值，所以方便起见可以直接这么说。

### 5.3 变量与属性
> 在函数内声明的变量是局部变量。作为函数参数的参数变量也是一种局部变量。
> 局部变量是在调用函数时被隐式生成的对象的属性。被隐式生成的对象称为 Call 对象。

### 5.5 对变量是否存在的检验
> 如果试图读取没有被声明的变量，则会引起RetftrenceEror异常，这是一种错误，必须对代码进行修正。
> ```js
> var a = a || 7;  // 一种习惯用法。如果变量a已经具有某值，则使用变量a的值
> ```
> 该代码利用了对已经声明的变量再次声明不会产生副作用的特性。像下面这样，分成两行并使用不同的变量，作用是一样的。
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（1）
> var a;
> var b = a || 7;
> ```
> 准确地说，这一代码并没有判断变量a是否已经被声明。例如在该例中，如果变量a的值是0或者是" （空字符），它在被转换为布尔型之后值就会为假，这时，代码中的变量b则会被赋值为7.
> 接下来的代码可能有些冗长，它直接判断变量a的值是否是undefined值，由此判断出变量a是否巴声明，或者是否在声明后值为undefined.
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（2）
> var a;
> var b=a Is undefined ? a: 7;
>```
> 虽说对同一变量再次声明不会有副作用，但每次都要写一遍var a也有些麻烦。为了避免这一问题可以通过typeof运算来判断是否为undefined值

> 这个例子利用了在JavaScript （ ECMAScript）中没有块级作用域的特性
> ```js
> //如果变量a已经具有某值，则使用变量a的值。代码示例（3）
> // （不使用var a的版本1
> if (typeof a l=s 'undefined) (
>  var b = a;
> } else {
>  var b = 7;
> }
> //从这里开始可以使用变量b
> ```
> 在以上这些代码中，无法区分变量a是还没声明，还是已经声明但值为undefined.

### 5.6 对象的定义
#### 5.6.1 抽象数据类型与面向对象
> 如果从形式上来定义 JavaScript 的对象，它就是一种属性的集合。所谓属性，即名称与值的配对。属性值可以被指定为任意类型的值，包括数组或其他的对象，都没有问题。
> 面向对象是一种程序设计方法，它已经被广泛接受，如今这已经不再仅仅是一种方法，而成为了一种思想。本书并不会对此深入探讨，仅对作为一种程序设计方法的面向对象技术进行说明。尽管作了这样的限定，面向对象仍具有多种含义。对于对象有一种很常见的定义，即它是一种数据和操作（子程序）的结合。这一定义可以理解为，将面向对象看作一种抽象数据类型的表现形式。
> 这种理解方式被 C++ 或 Java 等语言所采用，是现在相对主流的见解。想必有很多读者都听说过面向对象的 3 要素，即封装、继承与多态吧。如果这样理解的话，面向对象程序设计的焦点就在于对象的执行方式，并将执行方式的共性定义为一种类型。
> 在这一语境中，常常使用类这一术语来表达类型的含义。也有些语言会把执行方式与其实现分开，将执行方式定义为接口。接口的实例（实体）被称为对象，可以对其进行指定的操作。

#### 5.6.2 实例间的协作关系与面向对象
> 另一种面向对象程序设计的观点认为，与其考虑执行方式之间的共性，更应该关注实例之间的协作关系，即所谓的对象是进行消息收发的实体。
> 对象收到消息之后将会对其作出响应。从实现的角度来看，消息的实质就是通过对方法（函数）进行调用，将对消息的响应分派给方法来处理。
> 从本质上来说，面向对象这一术语只不过是一种在高于内部实现的语境中所使用的、较为抽象的概念而已。打个比方，可以把消息当作一种通信协议，把对象当作一个 Web 应用。

#### 5.6.3 JavaScript 的对象
> JavaScript 语言所支持的面向对象与后者的理解更为相近。在 JavaScript 中，一切都是对象。对象之间的协作（消息收发）通过属性访问（以及方法的调用）来实现。
> 而对象之间的共性，则是通过继承同一个对象的性质的方式来实现。JavaScript 通过基于原型的形式来实现继承。
> 一旦要对面向对象的概念进行说明，事情就会变得很抽象。如果只考虑具体该如何使用 JavaScript 的对象，就不必考虑那么多复杂的问题。只需要考虑最核心的内容，将其理解为在程序中可以进行操作的数据的一种扩充即可。
> 此外，还可以通过函数方法的形式来表示对数据进行操作的子程序。这种想法的核心就是将对象的功能进行拆分并分别进行处理。分割本身也只不过是一种手段。毕竟，面向对象方法的最终目的是降低程序的复杂程度。

### 5.7 对象的生成
#### 5.7.2 构造函数与 new 表达式
> **构造函数调用**
> 构造函数在最后会隐式地执行 return this 操作。
> 那么，如果在构造函数中显式地写有 return 语句，会发生什么情况呢？结果可能不容易理解。通过 return 返回一个对象之后，它将成为调用构造函数的 new 表达式的值。
> 也就是说，使用 new 表达式后返回的，可能是所生成的对象以外的其他对象。
> 然而，如果调用的构造函数中的 return 返回的是基本类型的值，则会无视这一返回值，仍然隐式地执行 return this 操作。
> 这种操作常常会造成混乱，我们建议不要再在构造函数内使用 return 语句。

### 5.8 属性的访问
> 生成的对象可以通过属性来访问。对于对象的引用可以使用点运算符（.）或中括号运算符（[]）来访问其属性。
> 需要注意的是，在点运算符之后书写的属性名会被认为是标识符，而中括号运算符内的则是被转为字符串值的式子。请看下面的例子：
> ```js
> var obj = { x:3, y:4 };
> print(obj.x); // 属性 x
> 3
> print(obj['x']);  // 属性 x
> 3
> var key = 'x';
> print(obj[key]);  // 属性 x（而非属性 key）
> 3
> ```
> 不过，对于对象字面量的属性名来说，下面这样的标识符或字符字面量形式的表示，都没问题。
> 请注意不要与上面的规则混淆。
> ```js
> var key = 'x';
> var obj = { key:3 };  // 属性 key（而非属性 x）
> var obj = { 'x':3 };  // 属性 x
> ```
> 这里需要多提一句，**属性访问的运算对象并不是变量，而是对象的引用**。这一点，可以从以下直接对对象字面量进行运算的示例中得到确认：
> ```js
>  ({x:3, y:4}).x;  // 属性 x
> 3
> ```
> 现实中几乎不会对对象字面量进行运算。不过当这种运算对象不是一个变量时，倒是常常会以方法链之类的形式出现。

### 5.9 作为关联数组的对象
#### 5.9.1 关联数组
> 首先对与关联数组相关的术语进行整理。将数值作为键的值的数据结构通常称为数组。数组是绝大多数程序设计语言都支持的一种基本的数据结构。
> 由于数组的键是连续的数值，因此可以将其看作具有顺序的值的集合。除了数值以外大多都会使用字符串作为键值。不过键的类型也可以不限于字符串，对任意类型的键与值的集合进行操作的数据结构称为关联数组。
> 在有些语言中，关联数组也被称为映射或字典。也有根据内部实现而将其称为散列的语言。虽然用词不同，但其数据结构是相同的，使用何种称法都可以。
> 关联数组最主要的用途是执行通过键来读取值的操作。在其他程序设计语言，特别是一些脚本语言中，关联数组被设计为一种语言本身的功能，不过在 JavaScript 中，必须通过对象来实现关联数组。
> **请注意，并没有专门用于关联数组的对象，这仅仅是对对象的一种不同的用法。**

**关联数组的操作方式**
> 关联数组是元素的集合，其元素为键与值的配对。关联数组的基本操作有通过键来获取值、元素的设定、元素的删除这 3 种。由于其实体是 JavaScript 的对象，所以这里的元素只不过是属性的另一种说法，而键与值分别是属性名与属性值的别称。
> 可以按照属性访问一节中的介绍，通过点运算符或中括号运算符来实现按键取值。严格地说，是将该值作为右值来使用。
> 对于元素的设定，可以将点运算符或是中括号运算符作为左值写入赋值表达式。
> 对象的删除可以通过 delete 运算符。用对象的术语来说就是删除属性。使用方法如下。
> ```js
> // 删除关联数组的元素的例子（属性的删除）
> var map = { x:3, y:4 };
> print(map.x);
> 3
> delete map.x;   // 也可以使用 delete map['x']
> true    // 如果删除成功，则返回 true
> print(map.x);   // 如果读取已被删除的元素，则返回 undefined 值
> undefined
> ```
> 在 C++ 语言中也有 delete 这个关键字，不过其功能却全然不同。
> 在 C++ 中 delete 的功能是释放所引用的对象的内存，而在 JavaScript 中 delete 只用于删除对象中的属性。
> 用映射中的术语来说就是，仅仅从映射中删除键，使其对应的值（对于对象来说也就是属性值）与该键不再有对应关系。虽然失去了引用的对象最终可能会因为垃圾回收机制而消失，不过这并不是 delete 运算的直接功能。
> 对不存在的元素进行访问得到的结果是 undefined 型。需要注意的是，这与 Java 中映射返回的 null是不同的。由于可以显式地将值设定为 undefined 值，因此无法通过将键与 undefined 值作等值比较来实现对键是否存在的检验。

#### 5.9.2 作为关联数组的对象的注意点
> 作为关联数组的对象有一些和原型继承相关的注意点。简单说来，原型继承指的是一种对象继承其他对象的属性并将其作为自身的属性一样来使用的做法。
> 如下所示，从形式上来说，对象 obj 的属性并不是其直接属性，而是通过原型继承而得到的属性。
> ```js
> function MyClass() {}
> MyClass.prototype.z = 5;    // 在原型链上设定属性 z
> var obj = new MyClass();    // 属性 z 继承了原形
> print(obj.z);
> 5
> ```
> for in 语句将枚举通过原型继承而得到的属性。
> ```js
> // 接之前的代码
> for (var key in obj) { print(key); }  // for in 语句也会枚举通过原型继承得到的属性
> z
> ```
> 请注意，通过原型继承而得到的属性无法被 delete。继续接之前的代码。
> ```js
> // 接之前的代码
> delete obj.z;   // 尽管没有被 delete，但还是会返回 true……
> true
> print(obj.z);   // 无法 delete 通过原型继承而得到的属性
> 5
> ```
> 在将对象作为关联数组使用时，通常都会使用对象字面量来生成。
> 不过需要注意的是，即使视图通过使用空的对象字面量以创建一个没有元素的关联数组，也仍然会从 Object 类中继承原型的属性。可以通过 in 运算对此进行检验。
> ```js
>  var map = {};  // 通过空的对象字面量生成关联数组
> 'toString' in map;  // 从 Object 类中原型继承了属性 toString
> true
> ```
> 但是，通过 for in 语句对元素进行枚举不会有任何效果。这是由于 enumerable 属性的缘故，将在之后的小节中说明。
> ```js
> // 接之前的代码
> for (var key in map) {
>   print(key);
> }   
> // 没有元素会被枚举
> ```
> 通过 in 运算符检测关联数组的键是否存在，就会发生与原型继承而来的属性相关的问题。
> 因此，像下面这样通过 hasOwnProperty 来对其进行检测，是一种更安全的做法。
> ```js
> var map = {};
> map.hasOwnProperty('toString');   // 由于 toString 不是直接属性，因此结果为 false
> false
> map['toString'] = 1;
> map.hasOwnProperty('toString');
> true
> delete map['toString'];
> map.hasOwnProperty('toString');
> false
> ```

### 5.13 方法
> 在 JavaScript 的语言规范中并不存在方法这一概念。方便起见，我们将作为对象属性的函数称为方法。
> 而在实际中可以像这样定义方法：那些使用了 this 引用来调用并访问了对象的属性的函数，被称为方法。
> 方法与函数名称两者可以随意混用，不过如果能注意到正在使用的是一个方法的话，就能更明确地意识到现在是在对对象进行操作。所以，使用方法这一名称的话会更有意义。