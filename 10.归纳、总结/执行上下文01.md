####  var 声明的变量和 function 声明的函数，创建在全局对象中，而 let const class 声明的变量创建在全局 scope中

####  当 JavaScript 代码运行时，先到全局 scope 中找变量，查找不到再到全局对象查找。

```
let aLet = 'aLet';
console.log(aLet);          // aLet
console.log(window.aLet);   // undefined

var aVar = 'aVar';
console.log(aVar);        // aVar
console.log(window.aVar); // aVar

console.log(Function);        // ƒ Function() { [native code] }
console.log(window.Function); // ƒ Function() { [native code] }

let Function = 'let 定义覆盖了 Function';
console.log(Function);        //let 定义覆盖了 Function
console.log(window.Function); // ƒ Function() { [native code] }

```

---

####  第一步：创建全局执行上下文，并加入栈顶
####  第二步：分析:

+  找到所有的非函数中的var声明；注意:如果是语句中有var 声明，也是会被收集，如下:

```
console.log(foo);
if(false){      // 虽然 if 语句中是 false,但下面 var 定义的变量还是会被收集
  var foo = 'foo';
}
```

+  找到所有的顶级函数声明(如果是在{}代码块中声明的函数，不会被收集)

+  找到顶级 let const class 声明

####  第三步：名字重复处理
+  let const class 声明的名字之间不能重复；如果重复，则报错。

+  let const class 和 var function 的名字不能重复，如果重复，则报错。

+  var 和 function 名字重复的， funtion 声明的函数优先

####  第四步：创建绑定，就是在当前的执行上下文中，登记这些变量。

+  登记并初始化 var 定义的变量为 undefined;

+  顶级函数声明:登记 function 名字，初始化为函数对象，将函数对象赋值绑定到创建的函数名字上；**也就是说,函数对象创建的时候，函数对象'体内'，会保存 ---> 函数创建时的 ---> 执行上下文的 ---> 文本环境的引用**

+  块级中函数声明:登记名字，初始化为 undefined;

+  登记 let const class，创建在全局的 scope 中，但没有初始化。

#### 第五步：执行语句，安装代码顺序，从上往下执行代码；

---

还是这个代码，分析如下:
```
console.log(foo);   // undefined
if(false){      
  var foo = 'foo';
}
```

+  第一步：创建全局执行上下文；在浏览器中就是创建全局的 window 对象，并设置 this 的值等于这个全局对象。

+  第二步：在全局执行上下文中收集并登记 var 声明的变量 foo ,初始化为 undefined ;并将 foo 添加为 window 对象的属性；

+  第三步：开始执行代码，在 `console.log(foo)`语句中，查找变量 foo 的值；

+  第四步：先在全局 scope 中查找变量 foo 的值；如果没有找到，就到全局对象中去查找；此时， foo 被初始化为 undefined, 所以，打印出 undefined

+  第五步：执行 if 语句；此时，if 语句为假，不执行里面语句；代码执行完。

---

再分析另一个例子:
```
var a = 10;
function foo(){
  console.log(a);
  let a;
}

foo();
```
+  第一步：创建全局执行上下文；在浏览器中就是创建全局的 window 对象，并设置 this 的值等于这个全局对象。

+  第二步：在全局执行上下文中收集并登记 var 声明的变量 a ,初始化为 undefined ;并将 a 添加为 window 对象的属性；**收集并登记函数 foo ,初始化为函数对象，将函数对象赋值绑定到创建的函数名字 foo 上,函数对象保存函数创建时的执行上下文的文本环境 ( 在这里，执行上下文就是全局执行上下文；此时的文本环境中，全局 scope 中什么都没有，而全局对象中声明了变量 a ,值为 undefined ;以及函数对象 foo )** ；将 foo 添加为 window 对象的方法；

+  第三步：先在全局 scope 中查找变量 a 的值；如果没有找到，就到全局对象中去查找；在全局对象中找到变量 a ，并赋值为10；

+  第四步：调用函数 foo()，创建函数 foo 的执行上下文，并压入栈顶；**此时，函数 foo 执行上下文就是函数对象保存函数创建时的执行上下文的文本环境**

+  第五步： 找到函数体内 let 声明，也就是 a;

+  第六步：名字重复处理，由于函数体内只有一个变量 a ,所以不用处理；

+  第七步：变量的创建，由于函数执行上下文与全局执行上下文不一样，只有函数的 scope ；在函数的 scope 创建变量 a ;由于 a 是通过 let 声明，并没有被初始化；初始化完毕，开始执行代码。

+  第八步：执行 `console.log(a)` 打印 a ；在当前函数的执行上下文中去找变量 a ；通过在函数的 scope 中找到变量 a, 但没有被初始化，会在控制台打印错误，因为未初始化的变量是不可以使用的；**像这样声明绑定的变量，但没有初始化状态，叫做临时死区 ( Temporal dead zone )**

---

+  作用域是解析 (查找) 变量名的一个集合，就是当前运行上下文 (也可以是当前上下文的词法环境 ( Lexical Environment ))

    +  全局作用域就是全局运行上下文
    +  函数作用域就是函数运行上下文

+  函数调用时的执行上下文看'身世'---函数在哪里创建，就保存哪里的运行上下文
    +  函数的作用域是在函数创建的时候决定的而不是调用的时候决定的

示例如下：
```
function foo(){
  console.log(a);
}

function bar(){
  var a = 3;
  foo();
}

var a = 2
bar();    // 2

```

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步： 分析；找到顶级函数声明 foo 、顶级函数声明 bar 和 var 声明的变量 a ；

+  第三步:名字重复处理；由于名字都没有重复，不会报错；

+  第四步:在全局上下文中登记这些变量(var 定义的变量和 function 定义的函数都是登记在全局对象上的)；**函数在创建的时候，都保存了创建时的执行上下文的文本环境**；

+  第五步：执行语句;全局执行上下文的 a 赋值为2；接着执行函数调用 bar(); **函数调用的时候会创建函数执行上下文，并压入栈顶**；bar 函数体内的执行上下文会以创建时的执行上下文为父(也就是全局执行上下文)；

+  第六步：在函数 bar 体内执行上下文，进行分析，并找到 var 定义的变量 a ;然后在 bar 函数执行上下文中登记变量 a ；并初始化为 undefined;

+  第七步：执行语句；在 bar 函数执行上下文中将变量 a 赋值为3；执行函数调用 foo();**函数调用的时候会创建函数执行上下文，并压入栈顶**；foo 函数体内的执行上下文会以创建时的执行上下文为父(也就是全局执行上下文)；

+  第八步：由于函数 foo 里面只有一条执行语句，直接执行语句，打印 a 的值；在当前函数执行上下文中寻找，也就是函数 foo 创建时的执行上下文中去查找(这里是在全局执行上下文中查找)，此时 变量 a 的值为2；最后打印2；

---

###  词法作用域链并非根据调用嵌套形成(运行上下文)作用域链，而是根据函数创建嵌套形成作用域链，也就是函数的书写位置形成作用域链。

---

###  块级作用域

+  第一步：创建新的记录环境，链接在原来记录之前。

+  第二步：分析
    
    +  所有的顶级函数声明；

    +  找到 let const 声明；

+  第三步：名字重复判断
    
    +  function 和 let const 名字不重复；

    +  let const 之间名字不重复；

+  第四步：创建绑定

    +  登记 function m名字，并初始化为新创建函数对象

    +  登记 let const 但未初始化

+  第五步：执行语句


```
let inIf = 'out if statement';

if(true) {
  let inIf = 'in if statement';
  console.log(inIf);
}

console.log(inIf);
```

分析：

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步：分析变量声明；找到顶级 let 声明，但没有初始化；

+  第三步： 语句执行；进行赋值操作，给 inIf 赋值为 'out if statement' ；

+  第四步:接着执行 if 代码块；创建新的记录环境也就是文本环境(**记住，不是执行上下文环境**)，并将它链接到原来的文本环境。

+  第五步：分析



