####  var 声明的变量和 function 声明的函数，创建在全局对象中，而 let const class 声明的变量创建在全局 scope中

####  当 JavaScript 代码运行时，先到全局 scope 中找变量，查找不到再到全局对象查找。

```
let aLet = 'aLet';
console.log(aLet);          // aLet
console.log(window.aLet);   // undefined

var aVar = 'aVar';
console.log(aVar);        // aVar
console.log(window.aVar); // aVar

console.log(Function);        // ƒ Function() { [native code] }
console.log(window.Function); // ƒ Function() { [native code] }

let Function = 'let 定义覆盖了 Function';
console.log(Function);        //let 定义覆盖了 Function
console.log(window.Function); // ƒ Function() { [native code] }

```

---

####  第一步：创建全局执行上下文，并加入栈顶
####  第二步：分析:

+  找到所有的非函数中的var声明；**注意:如果是语句中有var 声明，也是会被收集;但如果语句中是 let const class 声明，在全局执行上下文中是不会被收集；**如下:

```
console.log(foo);
if(false){      // 虽然 if 语句中是 false,但下面 var 定义的变量还是会被收集
  var foo = 'foo';
}
```

+  找到所有的顶级函数声明(如果是在{}代码块中声明的函数，不会被收集)

+  找到顶级 let const class 声明

####  第三步：名字重复处理
+  let const class 声明的名字之间不能重复；如果重复，则报错。

+  let const class 和 var function 的名字不能重复，如果重复，则报错。

+  var 和 function 名字重复的， funtion 声明的函数优先

####  第四步：创建绑定，就是在当前的执行上下文中，登记这些变量。

+  登记并初始化 var 定义的变量为 undefined;

+  顶级函数声明:登记 function 名字，初始化为函数对象，将函数对象赋值绑定到创建的函数名字上；**也就是说,函数对象创建的时候，函数对象'体内'，会保存 ---> 函数创建时的 ---> 执行上下文的 ---> 文本环境的引用**

+  块级中函数声明:登记名字，初始化为 undefined;

+  登记 let const class，创建在全局的 scope 中，但没有初始化。

#### 第五步：执行语句，安装代码顺序，从上往下执行代码；

---

还是这个代码，分析如下:
```
console.log(foo);   // undefined
if(false){      
  var foo = 'foo';
}
```

+  第一步：创建全局执行上下文；在浏览器中就是创建全局的 window 对象，并设置 this 的值等于这个全局对象。

+  第二步：在全局执行上下文中收集并登记 var 声明的变量 foo ,初始化为 undefined ;并将 foo 添加为 window 对象的属性；

+  第三步：开始执行代码，在 `console.log(foo)`语句中，查找变量 foo 的值；

+  第四步：先在全局 scope 中查找变量 foo 的值；如果没有找到，就到全局对象中去查找；此时， foo 被初始化为 undefined, 所以，打印出 undefined

+  第五步：执行 if 语句；此时，if 语句为假，不执行里面语句；代码执行完。

---

再分析另一个例子:
```
var a = 10;
function foo(){
  console.log(a);
  let a;
}

foo();
```
+  第一步：创建全局执行上下文；在浏览器中就是创建全局的 window 对象，并设置 this 的值等于这个全局对象。

+  第二步：在全局执行上下文中收集并登记 var 声明的变量 a ,初始化为 undefined ;并将 a 添加为 window 对象的属性；**收集并登记函数 foo ,初始化为函数对象，将函数对象赋值绑定到创建的函数名字 foo 上,函数对象保存函数创建时的执行上下文的文本环境 ( 在这里，执行上下文就是全局执行上下文；此时的文本环境中，全局 scope 中什么都没有，而全局对象中声明了变量 a ,值为 undefined ;以及函数对象 foo )** ；将 foo 添加为 window 对象的方法；

+  第三步：先在全局 scope 中查找变量 a 的值；如果没有找到，就到全局对象中去查找；在全局对象中找到变量 a ，并赋值为10；

+  第四步：调用函数 foo()，创建函数 foo 的执行上下文，并压入栈顶；**此时，函数 foo 执行上下文就是函数对象保存函数创建时的执行上下文的文本环境**

+  第五步： 找到函数体内 let 声明，也就是 a;

+  第六步：名字重复处理，由于函数体内只有一个变量 a ,所以不用处理；

+  第七步：变量的创建，由于函数执行上下文与全局执行上下文不一样，只有函数的 scope ；在函数的 scope 创建变量 a ;由于 a 是通过 let 声明，并没有被初始化；初始化完毕，开始执行代码。

+  第八步：执行 `console.log(a)` 打印 a ；在当前函数的执行上下文中去找变量 a ；通过在函数的 scope 中找到变量 a, 但没有被初始化，会在控制台打印错误，因为未初始化的变量是不可以使用的；**像这样声明绑定的变量，但没有初始化状态，叫做临时死区 ( Temporal dead zone )**

---

+  作用域是解析 (查找) 变量名的一个集合，就是当前运行上下文 (也可以是当前上下文的词法环境 ( Lexical Environment ))

    +  全局作用域就是全局运行上下文
    +  函数作用域就是函数运行上下文

+  函数调用时的执行上下文看'身世'---函数在哪里创建，就保存哪里的运行上下文
    +  函数的作用域是在函数创建的时候决定的而不是调用的时候决定的

####  分析:全局作用域中声明函数和变量 let 声明详情
示例如下：
```
function foo(){
  console.log(a);
}

function bar(){
  var a = 3;
  foo();
}

var a = 2
bar();    // 2

```

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步： 分析；找到顶级函数声明 foo 、顶级函数声明 bar 和 var 声明的变量 a ；

+  第三步:名字重复处理；由于名字都没有重复，不会报错；

+  第四步:在全局上下文中登记这些变量(var 定义的变量和 function 定义的函数都是登记在全局对象上的)；**函数在创建的时候，都保存了创建时的执行上下文的文本环境**；

+  第五步：执行语句;全局执行上下文的 a 赋值为2；接着执行函数调用 bar(); **函数调用的时候会创建函数执行上下文，并压入栈顶**；bar 函数体内的执行上下文会以创建时的执行上下文为父(也就是全局执行上下文)；

+  第六步：在函数 bar 体内执行上下文，进行分析，并找到 var 定义的变量 a ;然后在 bar 函数执行上下文中登记变量 a ；并初始化为 undefined;

+  第七步：执行语句；在 bar 函数执行上下文中将变量 a 赋值为3；执行函数调用 foo();**函数调用的时候会创建函数执行上下文，并压入栈顶**；foo 函数体内的执行上下文会以创建时的执行上下文为父(也就是全局执行上下文)；

+  第八步：由于函数 foo 里面只有一条执行语句，直接执行语句，打印 a 的值；在当前函数执行上下文中寻找，也就是函数 foo 创建时的执行上下文中去查找(这里是在全局执行上下文中查找)，此时 变量 a 的值为2；最后打印2；

---

###  词法作用域链并非根据调用嵌套形成(运行上下文)作用域链，而是根据函数创建嵌套形成作用域链，也就是函数的书写位置形成作用域链。

---

###  块级作用域

+  第一步：创建新的记录环境，链接在原来记录之前。

+  第二步：分析
    
    +  所有的顶级函数声明；

    +  找到 let const 声明；**(不用找 var 声明，这是因为 var 声明在之前的全局执行上下文中已经查找了)**

+  第三步：名字重复判断
    
    +  function 和 let const 名字不重复；

    +  let const 之间名字不重复；

+  第四步：创建绑定

    +  登记 function m名字，并初始化为新创建函数对象

    +  登记 let const 但未初始化

+  第五步：执行语句

---

#### 分析:块级作用域中声明 let 变量详情
```
let inIf = 'out if statement';

if(true) {
  let inIf = 'in if statement';
  console.log(inIf);    // in if statement
}

console.log(inIf);      // out if statement
```

分析：

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步：分析变量声明；找到顶级 let 声明，但没有初始化；

+  第三步： 语句执行；进行赋值操作，给 inIf 赋值为 'out if statement' ；

+  第四步:接着执行 if 代码块；在 if 代码块中，会创建新的记录环境也就是文本环境(**记住，不是执行上下文环境**)，并将它链接到原来的文本环境。

+  第五步：在 if 代码块的记录环境中，分析：

    +  在 if 代码块的记录环境中，找到所有的顶级函数声明；这里没有声明函数。

    +  在 if 代码块的记录环境中，找到所有的 let const 声明；这里用 let 声明了变量 inIf,但没有初始化。

+  第六步：在 if 代码块的记录环境中，进行名字重复处理；这里没有名字重复。

+  第七步： 在 if 代码块的记录环境中，创建绑定；绑定 let 声明的变量 inIf。

+  第八步：在 if 代码块的记录环境中，执行语句；将变量 inIf 赋值为 'in if statement'；接着执行第二条语句，打印 inIf 的值;控制台打印为 in if statement。

+  第九步：在 if 代码块执行完后。**JS引擎会销毁 if 代码块的记录环境 (文本环境)，并将全局执行上下文的文本环境接为原来的全局执行上下文文本环境。**所以，在执行最后一行代码，打印 inIf 值的时候，其实打印的是之前执行上下文的文本环境中的 inIf 的值，最后控制台打印出 out if statement。

---
#### 分析:块级作用域中声明函数详情

```
console.log(foo);   // undefined

if(true){
  function foo() {
    console.log('in block');
  }
}

foo();            // in block
```

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步： 分析

    +  找到所有的非函数中的 var 声明；

    +  找到所有的顶级函数声明；

    +  找到顶级 let const class 声明；

    +  **找到块中的函数声明，判断块中的函数名是否与上述3个步骤中找到的名字重复；如果重复，则对块中的函数声明不做任何处理；如果不重复，就会在全局对象当中，创建一个以函数名为名的变量，并把它初始化为 undefined;**

在这个 if 代码块的示例中，就是这种情况，没有 var 声明，没有顶级函数声明，也没有顶级 let const class 声明。**所以，会在全局对象上面创建一个名为 foo 的变量，值为 undefined;**

+  第三步：开始执行代码；打印 foo ；这时候会在控制台打印 undefined；**注意：这里的 foo 被提升了，和顶级函数提升是不一样的；顶级函数对象被提升的时候，函数对象已经创建完了；但是，块中函数名被提升了，是没有初始化，没有对象，是 undefined；也就是说，这个时候调用 foo 是会出错的；因为它还是不是函数，还没有初始化；**

+  第四步: 执行 if 代码块；创建一个块的文本环境，并链接到原来的文本环境中去；

+  第五步：重复第二步的步骤，找到函数声明 foo ，在 if 块的文本环境里面创建一个函数 foo ，同时初始化为函数对象，**这个函数对象'体内'保存的文本环境就是 if 块的文本环境；**

+  第六步：当 if 块语句中的代码执行完，if 块语句要退出的时候，**JS引擎会销毁 if 代码块的记录环境 (文本环境)，并将全局执行上下文的文本环境接为原来的全局执行上下文文本环境。**

**但是**， if 块语句中声明了一个函数，这里会增加一个逻辑，当退出 if 块语句的时候，除了将文本环境链接为原来的文本环境，还会做一个操作，就是到全局对象里面，查看是否有一个叫 foo 名字的变量，如果有，就把 if 块语句中 foo 的值赋给全局变量中 foo 的值，相当于覆盖；如果全局对象中没有 foo 这个变量，那么就做任何处理的。

因此，在这个示例中，之前执行第二步时，全局对象上创建了一个名为 foo 的变量，值为 undefined；现在全局对象上 foo 的值被 if 块语句中 foo 的值覆盖。

+  第七步：执行最后一条代码，调用 foo 函数；此时，会创建一个名为 foo 函数执行上下文；foo 函数的执行上下文，是这个函数定义时的执行上下文，也就是 if 块语句的文本环境；而 if 块语句在创建的文本环境时，里面创建一个函数 foo ，最初是初始化为函数对象，值为 undefined ；但是，在 if 块语句执行完后，全局对象上 foo 的值被 if 块语句中 foo 的值覆盖,此时， foo 值为 'in block'。 最后，控制台打印 'in block'。

---
####  块作用域中声明的函数也是有提升的；但是，提升的时候，值为 undefined，没有创建函数。

```
console.log(foo);   // undefined

if(false){
  function foo() {
    console.log('123');
  }
}
```

#####  `console.log(foo)`会成功打印吗？

由于 if 判断为 false，所以，if 代码块里面的代码是永远不会执行的；但是，打印 foo ，是有值的，值为 undefined，并不会报错。

---
#####  那如果换成这样呢？

```
let foo;

if(true){
  function foo() {
    console.log('123');
  }
}

foo();  // 报错 Uncaught TypeError: foo is not a function
```

#####  `foo()`调用会成功吗？

不会的；**因为全局执行上下文创建并压入栈顶后会做下面几件事:1.会找到所有的非函数中的 var 声明；2.找到所有的顶级函数声明；3.找到顶级 let const class 声明；4.当找到块中的函数声明时，判断块中的函数名是否与上述3个步骤中找到的名字重复；如果重复，则对块中的函数声明不做任何处理；如果不重复，就会在全局对象当中，创建一个以函数名为名的变量，并把它初始化为 undefined;**

而 if 块语句中的函数名 foo 与 顶级 let 声明的变量名 foo 重复；因此，块中的函数声明不做任何处理；

由于 if 判断为true, if 块语句会执行并生成 if 块语句的文本环境，里面声明了函数 foo ；当 if 块语句执行完毕，会做两件事：

+ 1.JS引擎会销毁 if 代码块的记录环境 (文本环境)，并将全局执行上下文的文本环境接为原来的全局执行上下文文本环境。

+ 2.if 块语句中声明了一个函数，这里会增加一个逻辑，当退出 if 块语句的时候，除了将文本环境链接为原来的文本环境，还会做一个操作，就是到**全局对象**里面，查看是否有一个叫 foo 名字的变量，如果有，就把 if 块语句中 foo 的值赋给全局变量中 foo 的值，相当于覆盖；如果**全局对象**中没有 foo 这个变量，那么就做任何处理的。

而全局执行上下中定义的变量 foo 是通过 let 定义的；**而 let 声明的变量创建在全局 scope 中；function 声明的函数定义在全局对象中。**

在这个示例中，全局 scope 中有变量 foo ；全局对象上没有变量 foo 。因此，尽管 if 块语句内声明了函数 foo ，但全局对象上没有 foo 这个变量，当 if 块语句执行完毕时，就会被JS引擎销毁。

所以，最后再调用 `foo()` 时就会报错。

---
#### 如果换成这样，那就会成功的

```
var foo;

if(true){
  function foo() {
    console.log('123');
  }
}

foo();  // 123
```

前面的分析和上一个示例差不多，区别是**var 声明的函数定义在全局对象中。**

---

#### 循环代码作用域

#####  如果 for 循环中用 let
```
var liList = [];

for(var i = 0; i < 5; i++) {
  liList[i] = function(){
    console.log(i);
  }
}

liList[0]();  // 5
liList[1]();  // 5
liList[2]();  // 5
liList[3]();  // 5
liList[4]();  // 5
```

+  第一步：创建全局执行上下文，压入栈顶；

+  第二步： 分析

    +  找到所有的非函数中的 var 声明；

    +  找到所有的顶级函数声明；

    +  找到顶级 let const class 声明；

    +  **找到块中的函数声明，判断块中的函数名是否与上述3个步骤中找到的名字重复；如果重复，则对块中的函数声明不做任何处理；如果不重复，就会在全局对象当中，创建一个以函数名为名的变量，并把它初始化为 undefined;**

这个示例中，找到 var 声明的 liList 和 i ,初始化为 undefined 。

+  第三步：执行代码；将 liList 赋值为空数组；i 赋值为0；接着执行 i<5 这个判断; i 在当前的全局执行上下文中值为0，小于5，符合判断，就执行 for 代码块；

    + 执行 for 代码块时，会创建新的文本环境并链接到全局上下文的文本环境；
    
    + 接着，创建一个函数表达式(function(){})，函数表达式也会创建一个函数(liList[0]函数对象)，这个函数在创建时保存着当前的执行上下文的文本环境；当前的执行上下文(for 代码块所在的执行上下文)是全局执行上下文。并将 `console.log(i)` 里面的 i 赋值为0。接着执行循环 `i++` 。

    + 一直到整个循环执行完后 i 的值为5，for 代码块的文本环境的链接会连回原来的文本环境。而循环创建的文本环境也没有被销毁，因为之后的对象有引用它们。

+  第四步：执行代码调用(liList[0]())；就会创建函数的执行上下文，**函数的执行上下文**会将它的文本环境链接到**它体内的文本环境**；而它体内的文本环境又是**函数创建时的文本环境**；所以，当执行打印 i 的值时，就会在函数的执行上下文中找 i 的值；如果没有，就会去它体内的文本环境中找 i 的值，也没有；再去函数创建时的文本环境(也就是全局执行上下文)中找，此时，i 为5。后面几次都和这次一样，找的都是全局对象上 i 的值。

最后，会打印5次 5。

---

##  总结：

###  JavaScript 变量先'登记'后使用，登记的地方叫地方执行上下文

  +  var 变量和函数声明'登记'时，创建在全局对象上，同时初始化，有'提升'现象

  + let const class 声明'登记'时，创建在'全局块'上面，未初始化，不能'提前'使用

  + 作用域可以理解为当前执行上下文的文本环境

###  4种情况会创建新的执行上下文:全局、function、eval、module

###  函数的作用域，只与其被创建时的执行上下文关联