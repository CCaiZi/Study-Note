TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。

把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。

而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。

值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。

## TCP/IP 协议族各层的作用如下。

### **应用层**

应用层决定了向用户提供应用服务时通信的活动。
TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。

HTTP 协议也处于该层。

### **传输层**

传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。

在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。

### **网络层（又名网络互连层）**

网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。

该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。

与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。

### **链路层（又名数据链路层，网络接口层）**

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。

硬件上的范畴均在链路层的作用范围之内。

## **TCP/IP 通信传输流**

利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。

> 发送端从应用层往下走，接收端则往应用层往上走。

我们用 HTTP 举例来说明，

> 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。

> 接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

> 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。

这样一来，发往网络的通信请求就准备齐全了。

> 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。

> 当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。

> 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。

> 反之，接收端在层与层传输数据时，每经过一层
> 时会把对应的首部消去。

> 这种把数据信息包装起来的做法称为封（encapsulate）。

## **负责传输的 IP 协议**

> IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。

> IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。

> IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。

> 使用 ARP 协议凭借 MAC 地址进行通信 IP 间的通信依赖 MAC 地址。

> 在网络上，通信的双方在同一局域网
> （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。

> 这时，会采用 ARP 协议（Address
> Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

## **确保可靠性的 TCP 协议**

> 按层次分，TCP 位于传输层，提供可靠的字节流服务。

> 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

> 而可靠的传输服务是指，能够把数据准确可靠地传给对方。

> 一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。

## **确保数据能到达目标**

> 为了准确无误地将数据送达目标处，TCP 协议采用了三次握手(three-way handshaking)策略。

> 用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。

> 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。

> 发送端首先发送一个带 SYN 标志的数据包给对方。

> 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。

> 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束

> 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

## **负责域名解析的 DNS 服务**

> DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

> 计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如www.hackr.jp。

> 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。

> 因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。

> ## **URI 和 URL**

> 与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。

> URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。比如，下图的 http://hackr.jp/ 就是 URL。

> ### **统一资源标识符**

> URI 是 Uniform Resource Identifier 的缩写。RFC2396 分别对这 3 个单词进行了如下定义。

> **Uniform**

> 规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。

> **Resource**

> 资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。

> **Identifier**

> 表示可标识的对象。也称为标识符。

> 综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、mailto、telnet、file 等。

> **URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。**

> **告知服务器意图的 HTTP 方法**

> GET ：获取资源

> GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；

> **POST：传输实体主体**

> **PUT：传输文件**

> PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

> 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。

> 若配合 Web 应用程序的验证机制，或架构设计采用
> REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。

> **HEAD：获得报文首部**

> HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

> **DELETE：删除文件**

> DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。

> 但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。

> **OPTIONS：询问支持的方法**

> OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

> **TRACE：追踪路径**

> TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

> 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。

> 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。

> 这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。

> 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。

> **CONNECT：要求用隧道协议连接代理**

> CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。

> 主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

---

> **HTTP/1.0 和 HTTP/1.1 支持的方法**

> 下表列出了 HTTP/1.0 和 HTTP/1.1 支持的方法。另外，方法名区分大小写，注意要用大写字母。

| 方法      | 说明                   | 支持的 HTTP 协议版本 |
| --------- | :--------------------- | :------------------- |
| GET       | 获取资源               | 1.0、1.1             |
| POST      | 传输实体主体           | 1.0、1.1             |
| PUT       | 传输文件               | 1.0、1.1             |
| HEAD      | 获得报文首部           | 1.0、1.1             |
| DELETE    | 删除文件               | 1.0、1.1             |
| OPTIONS   | 询问支持的方法         | 1.1                  |
| TRACE     | 追踪路径               | 1.1                  |
| CONNECT   | 要求用隧道协议连接代理 | 1.1                  |
| LINK      | 建立和资源之间的联系   | 1.0                  |
| GEUNLINET | 断开连接关系           | 1.0                  |
|           |                        |

> 在这里列举的众多方法中，LINK 和 UNLINK 已被 HTTP/1.1 废弃，不再支持。

---

> ## 使用 Cookie 的状态管理

> HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

> Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。

> 当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

> 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

---

> ## **HTTP 报文**

> HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

---

> **请求报文和响应报文的首部内容由以下数据组成。**

> **请求行**

> 包含用于请求的方法，请求 URI 和 HTTP 版本。

> **状态行**

> 包含表明响应结果的状态码，原因短语和 HTTP 版本。

> **首部字段**

> 包含表示请求和响应的各种条件和属性的各类首部。

> 一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。

> **其他**

> 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。

---

> ## 内容协商返回最合适的内容

> 同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。

> 当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。

---

> ## **内容协商技术有以下 3 种类型。**

> **服务器驱动协商（Server-driven Negotiation）**

> 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。

> **客户端驱动协商（Agent-driven Negotiation）**

> 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。

> 比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。

> **透明协商（Transparent Negotiation）**

> 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

---
